{"ast":null,"code":"import { useRef, useLayoutEffect, useMemo, useState, useCallback, useEffect, useContext, createContext, memo, forwardRef, useImperativeHandle } from 'react';\nimport clsx from 'clsx';\nimport { jsxs, jsx, Fragment } from 'react/jsx-runtime';\nimport { createPortal } from 'react-dom';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z$b = \".c1wupbe700-canary49{contain:strict;contain:size layout style paint;padding:0 8px;border-right:1px solid var(--border-color);border-bottom:1px solid var(--border-color);background-color:inherit;white-space:nowrap;overflow:hidden;overflow:clip;text-overflow:ellipsis}.c1wupbe700-canary49[aria-selected=true]{box-shadow:inset 0 0 0 2px var(--selection-color)}.cd0kgiy700-canary49{position:sticky;z-index:1}.c1730fa4700-canary49{box-shadow:2px 0 5px -2px hsla(0,0%,53.3%,.3)}\";\nstyleInject(css_248z$b);\nconst cell = \"c1wupbe700-canary49\";\nconst cellClassname = `rdg-cell ${cell}`;\nconst cellFrozen = \"cd0kgiy700-canary49\";\nconst cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\nconst cellFrozenLast = \"c1730fa4700-canary49\";\nconst cellFrozenLastClassname = `rdg-cell-frozen-last ${cellFrozenLast}`;\nvar css_248z$a = \".r104f42s700-canary49{--color:#000;--border-color:#ddd;--summary-border-color:#aaa;--background-color:hsl(0deg 0% 100%);--header-background-color:hsl(0deg 0% 97.5%);--row-hover-background-color:hsl(0deg 0% 96%);--row-selected-background-color:hsl(207deg 76% 92%);--row-selected-hover-background-color:hsl(207deg 76% 88%);--checkbox-color:hsl(207deg 100% 29%);--checkbox-focus-color:hsl(207deg 100% 69%);--checkbox-disabled-border-color:#ccc;--checkbox-disabled-background-color:#ddd;--selection-color:#66afe9;--font-size:14px;contain:strict;contain:size layout style paint;content-visibility:auto;height:350px;border:1px solid var(--border-color);box-sizing:border-box;overflow:auto;user-select:none;background-color:var(--background-color);color:var(--color);font-size:var(--font-size)}@supports not (contain:strict){.r104f42s700-canary49{position:relative;z-index:0}}.r104f42s700-canary49 *,.r104f42s700-canary49 :after,.r104f42s700-canary49 :before{box-sizing:inherit}.r104f42s700-canary49.rdg-dark{--color:#ddd;--border-color:#444;--summary-border-color:#555;--background-color:hsl(0deg 0% 13%);--header-background-color:hsl(0deg 0% 10.5%);--row-hover-background-color:hsl(0deg 0% 9%);--row-selected-background-color:hsl(207deg 76% 42%);--row-selected-hover-background-color:hsl(207deg 76% 38%);--checkbox-color:hsl(207deg 100% 79%);--checkbox-focus-color:hsl(207deg 100% 89%);--checkbox-disabled-border-color:#000;--checkbox-disabled-background-color:#333}@media (prefers-color-scheme:dark){.r104f42s700-canary49:not(.rdg-light){--color:#ddd;--border-color:#444;--summary-border-color:#555;--background-color:hsl(0deg 0% 13%);--header-background-color:hsl(0deg 0% 10.5%);--row-hover-background-color:hsl(0deg 0% 9%);--row-selected-background-color:hsl(207deg 76% 42%);--row-selected-hover-background-color:hsl(207deg 76% 38%);--checkbox-color:hsl(207deg 100% 79%);--checkbox-focus-color:hsl(207deg 100% 89%);--checkbox-disabled-border-color:#000;--checkbox-disabled-background-color:#333}}.f7ly7s700-canary49{position:sticky;top:0;left:0;height:0;width:0;outline:0}.vc4f4zb700-canary49.r1otpg64700-canary49{cursor:move}\";\nstyleInject(css_248z$a);\nconst root = \"r104f42s700-canary49\";\nconst rootClassname = `rdg ${root}`;\nconst focusSink = \"f7ly7s700-canary49\";\nconst focusSinkClassname = `rdg-focus-sink ${focusSink}`;\nconst viewportDragging = \"vc4f4zb700-canary49\";\nconst viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\nvar css_248z$9 = \".g1cvx5us700-canary49:not([aria-selected=true]){background-color:var(--header-background-color)}.g1cvx5us700-canary49>.c1wupbe700-canary49:not(:last-child):not(.c1730fa4700-canary49){border-right:none}.g1j2w62i700-canary49:after{content:\\\"\\\";position:absolute;top:0;right:0;bottom:0;left:0;box-shadow:inset 0 0 0 2px var(--selection-color);pointer-events:none;z-index:2}.g1j2w62i700-canary49>.c1wupbe700-canary49:first-child{box-shadow:inset 2px 0 0 0 var(--selection-color)}\";\nstyleInject(css_248z$9);\nconst groupRow = \"g1cvx5us700-canary49\";\nconst groupRowClassname = `rdg-group-row ${groupRow}`;\nconst groupRowSelected = \"g1j2w62i700-canary49\";\nconst groupRowSelectedClassname = `rdg-group-row-selected ${groupRowSelected}`;\nvar css_248z$8 = \".h1fquj5h700-canary49{contain:strict;contain:size layout style paint;display:grid;grid-template-columns:var(--template-columns);grid-template-rows:var(--header-row-height);height:var(--header-row-height);line-height:var(--header-row-height);width:var(--row-width);position:sticky;top:0;background-color:var(--header-background-color);font-weight:700;z-index:3;touch-action:none}\";\nstyleInject(css_248z$8);\nconst headerRow = \"h1fquj5h700-canary49\";\nconst headerRowClassname = `rdg-header-row ${headerRow}`;\nvar css_248z$7 = \".r1otpg64700-canary49{contain:strict;contain:size layout style paint;display:grid;grid-template-rows:var(--row-height);grid-template-columns:var(--template-columns);position:absolute;left:0;width:var(--row-width);height:var(--row-height);line-height:var(--row-height);background-color:var(--background-color)}.r1otpg64700-canary49:hover{background-color:var(--row-hover-background-color)}.r1otpg64700-canary49[aria-selected=true]{background-color:var(--row-selected-background-color)}.r1otpg64700-canary49[aria-selected=true]:hover{background-color:var(--row-selected-hover-background-color)}.sel5gk2700-canary49{position:sticky;z-index:3;grid-template-rows:var(--summary-row-height);height:var(--summary-row-height);line-height:var(--summary-row-height)}.sel5gk2700-canary49>.c1wupbe700-canary49{border-top:2px solid var(--summary-border-color)}\";\nstyleInject(css_248z$7);\nconst row = \"r1otpg64700-canary49\";\nconst rowClassname = `rdg-row ${row}`;\nconst summaryRow = \"sel5gk2700-canary49\";\nconst summaryRowClassname = `rdg-summary-row ${summaryRow}`;\n\nfunction useFocusRef(isCellSelected) {\n  const ref = useRef(null);\n  useLayoutEffect(() => {\n    var _ref$current;\n\n    if (!isCellSelected) return;\n    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus({\n      preventScroll: true\n    });\n  }, [isCellSelected]);\n  return ref;\n}\n\nvar css_248z$6 = \".c1w6d5eo700-canary49{cursor:pointer;display:flex;align-items:center;justify-content:center;position:absolute;top:0;right:0;bottom:0;left:0;margin-right:1px}.c1h7iz8d700-canary49{all:unset;width:0;margin:0}.cc79ydj700-canary49{content:\\\"\\\";width:20px;height:20px;border:2px solid var(--border-color);background-color:var(--background-color)}.c1h7iz8d700-canary49:checked+.cc79ydj700-canary49{background-color:var(--checkbox-color);box-shadow:inset 0 0 0 4px var(--background-color)}.c1h7iz8d700-canary49:focus+.cc79ydj700-canary49{border-color:var(--checkbox-focus-color)}.c1e5jt0b700-canary49{cursor:default}.c1e5jt0b700-canary49 .cc79ydj700-canary49{border-color:var(--checkbox-disabled-border-color);background-color:var(--checkbox-disabled-background-color)}\";\nstyleInject(css_248z$6);\nconst checkboxLabel = \"c1w6d5eo700-canary49\";\nconst checkboxLabelClassname = `rdg-checkbox-label ${checkboxLabel}`;\nconst checkboxInput = \"c1h7iz8d700-canary49\";\nconst checkboxInputClassname = `rdg-checkbox-input ${checkboxInput}`;\nconst checkbox = \"cc79ydj700-canary49\";\nconst checkboxClassname = `rdg-checkbox ${checkbox}`;\nconst checkboxLabelDisabled = \"c1e5jt0b700-canary49\";\nconst checkboxLabelDisabledClassname = `rdg-checkbox-label-disabled ${checkboxLabelDisabled}`;\n\nfunction SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}) {\n  const inputRef = useFocusRef(isCellSelected);\n\n  function handleChange(e) {\n    onChange(e.target.checked, e.nativeEvent.shiftKey);\n  }\n\n  return /*#__PURE__*/jsxs(\"label\", {\n    className: clsx(checkboxLabelClassname, disabled && checkboxLabelDisabledClassname),\n    children: [/*#__PURE__*/jsx(\"input\", {\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      tabIndex: tabIndex,\n      ref: inputRef,\n      type: \"checkbox\",\n      className: checkboxInputClassname,\n      disabled: disabled,\n      checked: value,\n      onChange: handleChange,\n      onClick: onClick\n    }), /*#__PURE__*/jsx(\"div\", {\n      className: checkboxClassname\n    })]\n  });\n}\n\nfunction ValueFormatter(props) {\n  try {\n    return /*#__PURE__*/jsx(Fragment, {\n      children: props.row[props.column.key]\n    });\n  } catch {\n    return null;\n  }\n}\n\nvar css_248z$5 = \".gch972y700-canary49{outline:none}.cz2qf0d700-canary49{margin-left:4px;stroke:currentColor;stroke-width:1.5px;fill:transparent;vertical-align:middle}.cz2qf0d700-canary49>path{transition:d .1s}\";\nstyleInject(css_248z$5);\nconst groupCellContent = \"gch972y700-canary49\";\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\nconst caret = \"cz2qf0d700-canary49\";\nconst caretClassname = `rdg-caret ${caret}`;\n\nfunction ToggleGroupFormatter({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}) {\n  const cellRef = useFocusRef(isCellSelected);\n\n  function handleKeyDown({\n    key\n  }) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n  return /*#__PURE__*/jsxs(\"span\", {\n    ref: cellRef,\n    className: groupCellContentClassname,\n    tabIndex: -1,\n    onKeyDown: handleKeyDown,\n    children: [groupKey, /*#__PURE__*/jsx(\"svg\", {\n      viewBox: \"0 0 14 8\",\n      width: \"14\",\n      height: \"8\",\n      className: caretClassname,\n      children: /*#__PURE__*/jsx(\"path\", {\n        d: d\n      })\n    })]\n  });\n}\n\nfunction getColSpan(column, lastFrozenColumnIndex, args) {\n  const colSpan = typeof column.colSpan === 'function' ? column.colSpan(args) : 1;\n\n  if (Number.isInteger(colSpan) && colSpan > 1 && (!column.frozen || column.idx + colSpan - 1 <= lastFrozenColumnIndex)) {\n    return colSpan;\n  }\n\n  return undefined;\n}\n\nfunction stopPropagation(event) {\n  event.stopPropagation();\n}\n\nconst nonInputKeys = new Set(['Unidentified', 'Alt', 'AltGraph', 'CapsLock', 'Control', 'Fn', 'FnLock', 'Meta', 'NumLock', 'ScrollLock', 'Shift', 'Tab', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Home', 'PageDown', 'PageUp', 'Insert', 'ContextMenu', 'Escape', 'Pause', 'Play', 'PrintScreen', 'F1', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']);\n\nfunction isCtrlKeyHeldDown(e) {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nfunction isDefaultCellInput(event) {\n  return !nonInputKeys.has(event.key);\n}\n\nfunction onEditorNavigation({\n  key,\n  target\n}) {\n  if (key === 'Tab' && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n    return target.matches('.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child');\n  }\n\n  return false;\n}\n\nfunction isSelectedCellEditable({\n  selectedPosition,\n  columns,\n  rows,\n  isGroupRow\n}) {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return !isGroupRow(row) && isCellEditable(column, row);\n}\n\nfunction isCellEditable(column, row) {\n  return column.editor != null && !column.rowGroup && (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false;\n}\n\nfunction getNextSelectedCellPosition({\n  cellNavigationMode,\n  columns,\n  colSpanColumns,\n  rows,\n  currentPosition,\n  nextPosition,\n  lastFrozenColumnIndex,\n  isCellWithinBounds,\n  isGroupRow\n}) {\n  const rowsCount = rows.length;\n  let position = nextPosition;\n\n  const setColSpan = moveRight => {\n    const row = rows[position.rowIdx];\n\n    if (!isGroupRow(row)) {\n      const posIdx = position.idx;\n\n      for (const column of colSpanColumns) {\n        const colIdx = column.idx;\n        if (colIdx > posIdx) break;\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n          type: 'ROW',\n          row\n        });\n\n        if (colSpan && posIdx > colIdx && posIdx < colSpan + colIdx) {\n          position.idx = colIdx + (moveRight ? colSpan : 0);\n          break;\n        }\n      }\n    }\n  };\n\n  if (isCellWithinBounds(position)) {\n    setColSpan(position.idx - currentPosition.idx > 0);\n  }\n\n  if (cellNavigationMode !== 'NONE') {\n    const {\n      idx,\n      rowIdx\n    } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n\n        if (!isLastRow) {\n          position = {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else {\n        position = {\n          rowIdx,\n          idx: 0\n        };\n      }\n\n      setColSpan(true);\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n\n        if (!isFirstRow) {\n          position = {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else {\n        position = {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n\n    setColSpan(false);\n  }\n\n  return position;\n}\n\nfunction canExitGrid({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  selectedPosition: {\n    rowIdx,\n    idx\n  },\n  shiftKey\n}) {\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nconst {\n  min,\n  max,\n  floor,\n  ceil,\n  sign\n} = Math;\n\nfunction assertIsValidKeyGetter(keyGetter) {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n\nfunction getCellStyle(column, colSpan) {\n  return {\n    gridColumnStart: column.idx + 1,\n    gridColumnEnd: colSpan !== undefined ? `span ${colSpan}` : undefined,\n    left: column.frozen ? `var(--frozen-left-${column.key})` : undefined\n  };\n}\n\nfunction getCellClassname(column, ...extraClasses) {\n  return clsx(cellClassname, ...extraClasses, column.frozen && cellFrozenClassname, column.isLastFrozenColumn && cellFrozenLastClassname);\n}\n\nconst SELECT_COLUMN_KEY = 'select-row';\n\nfunction SelectFormatter(props) {\n  const [isRowSelected, onRowSelectionChange] = useRowSelection();\n  return /*#__PURE__*/jsx(SelectCellFormatter, {\n    \"aria-label\": \"Select\",\n    tabIndex: -1,\n    isCellSelected: props.isCellSelected,\n    value: isRowSelected,\n    onClick: stopPropagation,\n    onChange: (checked, isShiftClick) => {\n      onRowSelectionChange({\n        rowIdx: props.rowIdx,\n        checked,\n        isShiftClick\n      });\n    }\n  });\n}\n\nfunction SelectGroupFormatter(props) {\n  const [isRowSelected, onRowSelectionChange] = useRowSelection();\n  return /*#__PURE__*/jsx(SelectCellFormatter, {\n    \"aria-label\": \"Select Group\",\n    tabIndex: -1,\n    isCellSelected: props.isCellSelected,\n    value: isRowSelected,\n    onChange: checked => {\n      onRowSelectionChange({\n        checked,\n        isShiftClick: false,\n        rowIdx: props.rowIdx\n      });\n    },\n    onClick: stopPropagation\n  });\n}\n\nconst SelectColumn = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n\n  headerRenderer(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select All\",\n      isCellSelected: false,\n      value: props.allRowsSelected,\n      onChange: props.onAllRowsSelectionChange\n    });\n  },\n\n  formatter: SelectFormatter,\n  groupFormatter: SelectGroupFormatter\n};\n\nfunction useCalculatedColumns({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy,\n  enableVirtualization\n}) {\n  var _defaultColumnOptions, _defaultColumnOptions2, _defaultColumnOptions3, _defaultColumnOptions4;\n\n  const minColumnWidth = (_defaultColumnOptions = defaultColumnOptions == null ? void 0 : defaultColumnOptions.minWidth) != null ? _defaultColumnOptions : 80;\n  const defaultFormatter = (_defaultColumnOptions2 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.formatter) != null ? _defaultColumnOptions2 : ValueFormatter;\n  const defaultSortable = (_defaultColumnOptions3 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.sortable) != null ? _defaultColumnOptions3 : false;\n  const defaultResizable = (_defaultColumnOptions4 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.resizable) != null ? _defaultColumnOptions4 : false;\n  const {\n    columns,\n    colSpanColumns,\n    lastFrozenColumnIndex,\n    groupBy\n  } = useMemo(() => {\n    const groupBy = [];\n    let lastFrozenColumnIndex = -1;\n    const columns = rawColumns.map(rawColumn => {\n      var _rawGroupBy$includes, _rawColumn$sortable, _rawColumn$resizable, _rawColumn$formatter;\n\n      const rowGroup = (_rawGroupBy$includes = rawGroupBy == null ? void 0 : rawGroupBy.includes(rawColumn.key)) != null ? _rawGroupBy$includes : false;\n      const frozen = rowGroup || rawColumn.frozen || false;\n      const column = { ...rawColumn,\n        idx: 0,\n        frozen,\n        isLastFrozenColumn: false,\n        rowGroup,\n        sortable: (_rawColumn$sortable = rawColumn.sortable) != null ? _rawColumn$sortable : defaultSortable,\n        resizable: (_rawColumn$resizable = rawColumn.resizable) != null ? _rawColumn$resizable : defaultResizable,\n        formatter: (_rawColumn$formatter = rawColumn.formatter) != null ? _rawColumn$formatter : defaultFormatter\n      };\n\n      if (rowGroup) {\n        var _column$groupFormatte;\n\n        (_column$groupFormatte = column.groupFormatter) != null ? _column$groupFormatte : column.groupFormatter = ToggleGroupFormatter;\n      }\n\n      if (frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n    columns.sort(({\n      key: aKey,\n      frozen: frozenA\n    }, {\n      key: bKey,\n      frozen: frozenB\n    }) => {\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      if (rawGroupBy != null && rawGroupBy.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n\n        return -1;\n      }\n\n      if (rawGroupBy != null && rawGroupBy.includes(bKey)) return 1;\n\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n\n      if (frozenB) return 1;\n      return 0;\n    });\n    const colSpanColumns = [];\n    columns.forEach((column, idx) => {\n      column.idx = idx;\n\n      if (column.rowGroup) {\n        groupBy.push(column.key);\n      }\n\n      if (column.colSpan != null) {\n        colSpanColumns.push(column);\n      }\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      columns[lastFrozenColumnIndex].isLastFrozenColumn = true;\n    }\n\n    return {\n      columns,\n      colSpanColumns,\n      lastFrozenColumnIndex,\n      groupBy\n    };\n  }, [rawColumns, defaultFormatter, defaultResizable, defaultSortable, rawGroupBy]);\n  const {\n    layoutCssVars,\n    totalColumnWidth,\n    totalFrozenColumnWidth,\n    columnMetrics\n  } = useMemo(() => {\n    const columnMetrics = new Map();\n    let left = 0;\n    let totalColumnWidth = 0;\n    let totalFrozenColumnWidth = 0;\n    let templateColumns = '';\n    let allocatedWidth = 0;\n    let unassignedColumnsCount = 0;\n\n    for (const column of columns) {\n      let width = getSpecifiedWidth(column, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, column, minColumnWidth);\n        allocatedWidth += width;\n        columnMetrics.set(column, {\n          width,\n          left: 0\n        });\n      }\n    }\n\n    const unallocatedWidth = viewportWidth - allocatedWidth;\n    const unallocatedColumnWidth = unallocatedWidth / unassignedColumnsCount;\n\n    for (const column of columns) {\n      let width;\n\n      if (columnMetrics.has(column)) {\n        const columnMetric = columnMetrics.get(column);\n        columnMetric.left = left;\n        ({\n          width\n        } = columnMetric);\n      } else {\n        width = clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n        columnMetrics.set(column, {\n          width,\n          left\n        });\n      }\n\n      totalColumnWidth += width;\n      left += width;\n      templateColumns += `${width}px `;\n    }\n\n    if (lastFrozenColumnIndex !== -1) {\n      const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex]);\n      totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n    }\n\n    const layoutCssVars = {\n      '--template-columns': templateColumns\n    };\n\n    for (let i = 0; i <= lastFrozenColumnIndex; i++) {\n      const column = columns[i];\n      layoutCssVars[`--frozen-left-${column.key}`] = `${columnMetrics.get(column).left}px`;\n    }\n\n    return {\n      layoutCssVars,\n      totalColumnWidth,\n      totalFrozenColumnWidth,\n      columnMetrics\n    };\n  }, [columnWidths, columns, viewportWidth, minColumnWidth, lastFrozenColumnIndex]);\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo(() => {\n    if (!enableVirtualization) {\n      return [0, columns.length - 1];\n    }\n\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n    while (colVisibleStartIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columnMetrics.get(columns[colVisibleStartIdx]);\n\n      if (left + width > viewportLeft) {\n        break;\n      }\n\n      colVisibleStartIdx++;\n    }\n\n    let colVisibleEndIdx = colVisibleStartIdx;\n\n    while (colVisibleEndIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columnMetrics.get(columns[colVisibleEndIdx]);\n\n      if (left + width >= viewportRight) {\n        break;\n      }\n\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = min(lastColIdx, colVisibleEndIdx + 1);\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columnMetrics, columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth, enableVirtualization]);\n  return {\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth({\n  key,\n  width\n}, columnWidths, viewportWidth) {\n  if (columnWidths.has(key)) {\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, {\n  minWidth,\n  maxWidth\n}, minColumnWidth) {\n  width = max(width, minWidth != null ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return min(width, maxWidth);\n  }\n\n  return width;\n}\n\nfunction useGridDimensions() {\n  const gridRef = useRef(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n  useLayoutEffect(() => {\n    const {\n      ResizeObserver\n    } = window;\n    if (ResizeObserver == null) return;\n    const resizeObserver = new ResizeObserver(() => {\n      const {\n        clientWidth,\n        clientHeight\n      } = gridRef.current;\n      setGridWidth(clientWidth - (devicePixelRatio % 0.5 === 0 ? 0 : 1));\n      setGridHeight(clientHeight);\n    });\n    resizeObserver.observe(gridRef.current);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n  return [gridRef, gridWidth, gridHeight];\n}\n\nfunction useLatestFunc(fn) {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  });\n  return useCallback((...args) => {\n    ref.current(...args);\n  }, []);\n}\n\nconst RowSelectionContext = /*#__PURE__*/createContext(undefined);\nconst RowSelectionProvider = RowSelectionContext.Provider;\nconst RowSelectionChangeContext = /*#__PURE__*/createContext(undefined);\nconst RowSelectionChangeProvider = RowSelectionChangeContext.Provider;\n\nfunction useRowSelection() {\n  const rowSelectionContext = useContext(RowSelectionContext);\n  const rowSelectionChangeContext = useContext(RowSelectionChangeContext);\n\n  if (rowSelectionContext === undefined || rowSelectionChangeContext === undefined) {\n    throw new Error('useRowSelection must be used within DataGrid cells');\n  }\n\n  return [rowSelectionContext, rowSelectionChangeContext];\n}\n\nfunction useViewportColumns({\n  columns,\n  colSpanColumns,\n  rows,\n  summaryRows,\n  colOverscanStartIdx,\n  colOverscanEndIdx,\n  lastFrozenColumnIndex,\n  rowOverscanStartIdx,\n  rowOverscanEndIdx,\n  isGroupRow\n}) {\n  const startIdx = useMemo(() => {\n    if (colOverscanStartIdx === 0) return 0;\n    let startIdx = colOverscanStartIdx;\n\n    const updateStartIdx = (colIdx, colSpan) => {\n      if (colSpan !== undefined && colIdx + colSpan > colOverscanStartIdx) {\n        startIdx = colIdx;\n        return true;\n      }\n\n      return false;\n    };\n\n    for (const column of colSpanColumns) {\n      const colIdx = column.idx;\n      if (colIdx >= startIdx) break;\n\n      if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n        type: 'HEADER'\n      }))) {\n        break;\n      }\n\n      for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n        const row = rows[rowIdx];\n        if (isGroupRow(row)) continue;\n\n        if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n          type: 'ROW',\n          row\n        }))) {\n          break;\n        }\n      }\n\n      if (summaryRows != null) {\n        for (const row of summaryRows) {\n          if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n            type: 'SUMMARY',\n            row\n          }))) {\n            break;\n          }\n        }\n      }\n    }\n\n    return startIdx;\n  }, [rowOverscanStartIdx, rowOverscanEndIdx, rows, summaryRows, colOverscanStartIdx, lastFrozenColumnIndex, colSpanColumns, isGroupRow]);\n  return useMemo(() => {\n    const viewportColumns = [];\n\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n      if (colIdx < startIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [startIdx, colOverscanEndIdx, columns]);\n}\n\nconst RENDER_BATCH_SIZE = 8;\n\nfunction isReadonlyArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction useViewportRows({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds,\n  enableVirtualization\n}) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || rowGrouper == null) return [undefined, rawRows.length];\n\n    const groupRows = (rows, [groupByKey, ...remainingGroupByKeys], startRowIndex) => {\n      let groupRowsCount = 0;\n      const groups = {};\n\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [childRows, childRows.length] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n        groups[key] = {\n          childRows,\n          childGroups,\n          startRowIndex: startRowIndex + groupRowsCount\n        };\n        groupRowsCount += childRowsCount + 1;\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n  const [rows, isGroupRow] = useMemo(() => {\n    const allGroupRows = new Set();\n    if (!groupedRows) return [rawRows, isGroupRow];\n    const flattenedRows = [];\n\n    const expandGroup = (rows, parentId, level) => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        var _expandedGroupIds$has;\n\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = (_expandedGroupIds$has = expandedGroupIds == null ? void 0 : expandedGroupIds.has(id)) != null ? _expandedGroupIds$has : false;\n        const {\n          childRows,\n          childGroups,\n          startRowIndex\n        } = rows[groupKey];\n        const groupRow = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, isGroupRow];\n\n    function isGroupRow(row) {\n      return allGroupRows.has(row);\n    }\n  }, [expandedGroupIds, groupedRows, rawRows]);\n  const {\n    totalRowHeight,\n    getRowTop,\n    getRowHeight,\n    findRowIdx\n  } = useMemo(() => {\n    if (typeof rowHeight === 'number') {\n      return {\n        totalRowHeight: rowHeight * rows.length,\n        getRowTop: rowIdx => rowIdx * rowHeight,\n        getRowHeight: () => rowHeight,\n        findRowIdx: offset => floor(offset / rowHeight)\n      };\n    }\n\n    let totalRowHeight = 0;\n    const rowPositions = rows.map(row => {\n      const currentRowHeight = isGroupRow(row) ? rowHeight({\n        type: 'GROUP',\n        row\n      }) : rowHeight({\n        type: 'ROW',\n        row\n      });\n      const position = {\n        top: totalRowHeight,\n        height: currentRowHeight\n      };\n      totalRowHeight += currentRowHeight;\n      return position;\n    });\n\n    const validateRowIdx = rowIdx => {\n      return max(0, min(rows.length - 1, rowIdx));\n    };\n\n    return {\n      totalRowHeight,\n      getRowTop: rowIdx => rowPositions[validateRowIdx(rowIdx)].top,\n      getRowHeight: rowIdx => rowPositions[validateRowIdx(rowIdx)].height,\n\n      findRowIdx(offset) {\n        let start = 0;\n        let end = rowPositions.length - 1;\n\n        while (start <= end) {\n          const middle = start + floor((end - start) / 2);\n          const currentOffset = rowPositions[middle].top;\n          if (currentOffset === offset) return middle;\n\n          if (currentOffset < offset) {\n            start = middle + 1;\n          } else if (currentOffset > offset) {\n            end = middle - 1;\n          }\n\n          if (start > end) return end;\n        }\n\n        return 0;\n      }\n\n    };\n  }, [isGroupRow, rowHeight, rows]);\n\n  if (!enableVirtualization) {\n    return {\n      rowOverscanStartIdx: 0,\n      rowOverscanEndIdx: rows.length - 1,\n      rows,\n      rowsCount,\n      totalRowHeight,\n      isGroupRow,\n      getRowTop,\n      getRowHeight,\n      findRowIdx\n    };\n  }\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = findRowIdx(scrollTop);\n  const rowVisibleEndIdx = min(rows.length - 1, findRowIdx(scrollTop + clientHeight));\n  const rowOverscanStartIdx = max(0, floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BATCH_SIZE) * RENDER_BATCH_SIZE);\n  const rowOverscanEndIdx = min(rows.length - 1, ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BATCH_SIZE) * RENDER_BATCH_SIZE);\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    totalRowHeight,\n    isGroupRow,\n    getRowTop,\n    getRowHeight,\n    findRowIdx\n  };\n}\n\nvar css_248z$4 = \".h13yq3r8700-canary49{cursor:pointer;display:flex}.ht6rdyl700-canary49{flex-grow:1;overflow:hidden;overflow:clip;text-overflow:ellipsis}\";\nstyleInject(css_248z$4);\nconst headerSortCell = \"h13yq3r8700-canary49\";\nconst headerSortCellClassname = `rdg-header-sort-cell ${headerSortCell}`;\nconst headerSortName = \"ht6rdyl700-canary49\";\nconst headerSortNameClassname = `rdg-header-sort-name ${headerSortName}`;\n\nfunction SortableHeaderCell({\n  onSort,\n  sortDirection,\n  priority,\n  children\n}) {\n  let sortText = '';\n\n  if (sortDirection === 'ASC') {\n    sortText = '\\u25B2';\n  } else if (sortDirection === 'DESC') {\n    sortText = '\\u25BC';\n  }\n\n  return /*#__PURE__*/jsxs(\"span\", {\n    className: headerSortCellClassname,\n    onClick: e => onSort(e.ctrlKey),\n    children: [/*#__PURE__*/jsx(\"span\", {\n      className: headerSortNameClassname,\n      children: children\n    }), /*#__PURE__*/jsxs(\"span\", {\n      children: [sortText, priority]\n    })]\n  });\n}\n\nvar css_248z$3 = \".celq7o9700-canary49:after{content:\\\"\\\";cursor:col-resize;position:absolute;top:0;right:0;bottom:0;width:10px}\";\nstyleInject(css_248z$3);\nconst cellResizable = \"celq7o9700-canary49\";\nconst cellResizableClassname = `rdg-cell-resizable ${cellResizable}`;\n\nfunction HeaderCell({\n  column,\n  colSpan,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumns,\n  onSortColumnsChange\n}) {\n  function onPointerDown(event) {\n    if (event.pointerType === 'mouse' && event.buttons !== 1) {\n      return;\n    }\n\n    const {\n      currentTarget,\n      pointerId\n    } = event;\n    const {\n      right\n    } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) {\n      return;\n    }\n\n    function onPointerMove(event) {\n      if (event.pointerId !== pointerId) return;\n\n      if (event.pointerType === 'mouse' && event.buttons !== 1) {\n        onPointerUp(event);\n        return;\n      }\n\n      const width = event.clientX + offset - currentTarget.getBoundingClientRect().left;\n\n      if (width > 0) {\n        onResize(column, width);\n      }\n    }\n\n    function onPointerUp(event) {\n      if (event.pointerId !== pointerId) return;\n      window.removeEventListener('pointermove', onPointerMove);\n      window.removeEventListener('pointerup', onPointerUp);\n    }\n\n    event.preventDefault();\n    window.addEventListener('pointermove', onPointerMove);\n    window.addEventListener('pointerup', onPointerUp);\n  }\n\n  const sortIndex = sortColumns == null ? void 0 : sortColumns.findIndex(sort => sort.columnKey === column.key);\n  const sortColumn = sortIndex !== undefined && sortIndex > -1 ? sortColumns[sortIndex] : undefined;\n  const sortDirection = sortColumn == null ? void 0 : sortColumn.direction;\n  const priority = sortColumn !== undefined && sortColumns.length > 1 ? sortIndex + 1 : undefined;\n  const ariaSort = sortDirection && !priority ? sortDirection === 'ASC' ? 'ascending' : 'descending' : undefined;\n\n  const onSort = ctrlClick => {\n    if (onSortColumnsChange == null) return;\n    const {\n      sortDescendingFirst\n    } = column;\n\n    if (sortColumn === undefined) {\n      const nextSort = {\n        columnKey: column.key,\n        direction: sortDescendingFirst ? 'DESC' : 'ASC'\n      };\n      onSortColumnsChange(sortColumns && ctrlClick ? [...sortColumns, nextSort] : [nextSort]);\n    } else {\n      let nextSortColumn;\n\n      if (sortDescendingFirst && sortDirection === 'DESC' || !sortDescendingFirst && sortDirection === 'ASC') {\n        nextSortColumn = {\n          columnKey: column.key,\n          direction: sortDirection === 'ASC' ? 'DESC' : 'ASC'\n        };\n      }\n\n      if (ctrlClick) {\n        const nextSortColumns = [...sortColumns];\n\n        if (nextSortColumn) {\n          nextSortColumns[sortIndex] = nextSortColumn;\n        } else {\n          nextSortColumns.splice(sortIndex, 1);\n        }\n\n        onSortColumnsChange(nextSortColumns);\n      } else {\n        onSortColumnsChange(nextSortColumn ? [nextSortColumn] : []);\n      }\n    }\n  };\n\n  function getCell() {\n    if (column.headerRenderer) {\n      return /*#__PURE__*/jsx(column.headerRenderer, {\n        column: column,\n        sortDirection: sortDirection,\n        priority: priority,\n        onSort: onSort,\n        allRowsSelected: allRowsSelected,\n        onAllRowsSelectionChange: onAllRowsSelectionChange\n      });\n    }\n\n    if (column.sortable) {\n      return /*#__PURE__*/jsx(SortableHeaderCell, {\n        onSort: onSort,\n        sortDirection: sortDirection,\n        priority: priority,\n        children: column.name\n      });\n    }\n\n    return column.name;\n  }\n\n  const className = getCellClassname(column, column.headerCellClass, column.resizable && cellResizableClassname);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"columnheader\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-sort\": ariaSort,\n    \"aria-colspan\": colSpan,\n    className: className,\n    style: getCellStyle(column, colSpan),\n    onPointerDown: column.resizable ? onPointerDown : undefined,\n    children: getCell()\n  });\n}\n\nfunction HeaderRow({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumns,\n  onSortColumnsChange,\n  lastFrozenColumnIndex\n}) {\n  const handleAllRowsSelectionChange = useCallback(checked => {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(checked ? rows.map(rowKeyGetter) : undefined);\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKeyGetter]);\n  const cells = [];\n\n  for (let index = 0; index < columns.length; index++) {\n    const column = columns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n      type: 'HEADER'\n    });\n\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    cells.push( /*#__PURE__*/jsx(HeaderCell, {\n      column: column,\n      colSpan: colSpan,\n      onResize: onColumnResize,\n      allRowsSelected: allRowsSelected,\n      onAllRowsSelectionChange: handleAllRowsSelectionChange,\n      onSortColumnsChange: onSortColumnsChange,\n      sortColumns: sortColumns\n    }, column.key));\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": 1,\n    className: headerRowClassname,\n    children: cells\n  });\n}\n\nconst HeaderRow$1 = /*#__PURE__*/memo(HeaderRow);\nvar css_248z$2 = \".c1bmg16t700-canary49,.ccpfvsn700-canary49{background-color:#ccf}.c1bmg16t700-canary49.ccpfvsn700-canary49{background-color:#99f}.c12t67zz700-canary49{cursor:move;position:absolute;right:0;bottom:0;width:8px;height:8px;background-color:var(--selection-color)}.c12t67zz700-canary49:hover{width:16px;height:16px;border:2px solid var(--selection-color);background-color:var(--background-color)}\";\nstyleInject(css_248z$2);\nconst cellCopied = \"ccpfvsn700-canary49\";\nconst cellCopiedClassname = `rdg-cell-copied ${cellCopied}`;\nconst cellDraggedOver = \"c1bmg16t700-canary49\";\nconst cellDraggedOverClassname = `rdg-cell-dragged-over ${cellDraggedOver}`;\nconst cellDragHandle = \"c12t67zz700-canary49\";\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\n\nfunction Cell({\n  className,\n  column,\n  colSpan,\n  isCellSelected,\n  isCopied,\n  isDraggedOver,\n  row,\n  rowIdx,\n  dragHandleProps,\n  onRowClick,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  onRowChange,\n  selectCell,\n  ...props\n}, ref) {\n  const {\n    cellClass\n  } = column;\n  className = getCellClassname(column, typeof cellClass === 'function' ? cellClass(row) : cellClass, className, isCopied && cellCopiedClassname, isDraggedOver && cellDraggedOverClassname);\n\n  function selectCellWrapper(openEditor) {\n    selectCell({\n      idx: column.idx,\n      rowIdx\n    }, openEditor);\n  }\n\n  function handleClick(event) {\n    var _column$editorOptions;\n\n    selectCellWrapper((_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.editOnClick);\n    onRowClick == null ? void 0 : onRowClick(rowIdx, row, column);\n    onClick == null ? void 0 : onClick(event);\n  }\n\n  function handleContextMenu(event) {\n    selectCellWrapper();\n    onContextMenu == null ? void 0 : onContextMenu(event);\n  }\n\n  function handleDoubleClick(event) {\n    selectCellWrapper(true);\n    onDoubleClick == null ? void 0 : onDoubleClick(event);\n  }\n\n  function handleRowChange(newRow) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": isCellSelected,\n    \"aria-colspan\": colSpan,\n    \"aria-readonly\": !isCellEditable(column, row) || undefined,\n    ref: ref,\n    className: className,\n    style: getCellStyle(column, colSpan),\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onContextMenu: handleContextMenu,\n    ...props,\n    children: !column.rowGroup && /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(column.formatter, {\n        column: column,\n        rowIdx: rowIdx,\n        row: row,\n        isCellSelected: isCellSelected,\n        onRowChange: handleRowChange\n      }), dragHandleProps && /*#__PURE__*/jsx(\"div\", {\n        className: cellDragHandleClassname,\n        ...dragHandleProps\n      })]\n    })\n  });\n}\n\nconst Cell$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Cell));\nvar css_248z$1 = \".c1tngyp1700-canary49{padding:0}\";\nstyleInject(css_248z$1);\nconst cellEditing = \"c1tngyp1700-canary49\";\nconst cellEditingClassname = `rdg-editor-container ${cellEditing}`;\n\nfunction EditCell({\n  column,\n  colSpan,\n  row,\n  rowIdx,\n  onRowChange,\n  onClose,\n  onKeyDown,\n  editorPortalTarget\n}) {\n  const frameRequestRef = useRef();\n  const commitOnOutsideMouseDown = useLatestFunc(() => {\n    onRowChange(row, true);\n  });\n\n  function cancelFrameRequest() {\n    cancelAnimationFrame(frameRequestRef.current);\n  }\n\n  useEffect(() => {\n    function onWindowCaptureMouseDown() {\n      frameRequestRef.current = requestAnimationFrame(commitOnOutsideMouseDown);\n    }\n\n    addEventListener('mousedown', onWindowCaptureMouseDown, {\n      capture: true\n    });\n    return () => {\n      removeEventListener('mousedown', onWindowCaptureMouseDown, {\n        capture: true\n      });\n      cancelFrameRequest();\n    };\n  }, [commitOnOutsideMouseDown]);\n  const {\n    cellClass\n  } = column;\n  const className = getCellClassname(column, cellEditingClassname, typeof cellClass === 'function' ? cellClass(row) : cellClass);\n  let content;\n\n  if (column.editor != null) {\n    var _column$editorOptions;\n\n    content = /*#__PURE__*/jsx(column.editor, {\n      column: column,\n      row: row,\n      rowIdx: rowIdx,\n      onRowChange: onRowChange,\n      onClose: onClose,\n      editorPortalTarget: editorPortalTarget\n    });\n\n    if ((_column$editorOptions = column.editorOptions) != null && _column$editorOptions.createPortal) {\n      content = /*#__PURE__*/createPortal(content, editorPortalTarget);\n    }\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": true,\n    className: className,\n    style: getCellStyle(column, colSpan),\n    onKeyDown: onKeyDown,\n    onMouseDownCapture: cancelFrameRequest,\n    children: content\n  });\n}\n\nfunction Row({\n  cellRenderer,\n  className,\n  rowIdx,\n  isRowSelected,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  lastFrozenColumnIndex,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  height,\n  onRowChange,\n  selectCell,\n  ...props\n}, ref) {\n  function handleDragEnter(event) {\n    setDraggedOverRowIdx == null ? void 0 : setDraggedOverRowIdx(rowIdx);\n    onMouseEnter == null ? void 0 : onMouseEnter(event);\n  }\n\n  className = clsx(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, rowClass == null ? void 0 : rowClass(row), className, (selectedCellProps == null ? void 0 : selectedCellProps.idx) === -1 && groupRowSelectedClassname);\n  const CellRenderer = cellRenderer != null ? cellRenderer : Cell$1;\n  const cells = [];\n\n  for (let index = 0; index < viewportColumns.length; index++) {\n    const column = viewportColumns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n      type: 'ROW',\n      row\n    });\n\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    const isCellSelected = (selectedCellProps == null ? void 0 : selectedCellProps.idx) === column.idx;\n\n    if ((selectedCellProps == null ? void 0 : selectedCellProps.mode) === 'EDIT' && isCellSelected) {\n      cells.push( /*#__PURE__*/jsx(EditCell, {\n        rowIdx: rowIdx,\n        column: column,\n        colSpan: colSpan,\n        onKeyDown: selectedCellProps.onKeyDown,\n        ...selectedCellProps.editorProps\n      }, column.key));\n      continue;\n    }\n\n    cells.push( /*#__PURE__*/jsx(CellRenderer, {\n      rowIdx: rowIdx,\n      column: column,\n      colSpan: colSpan,\n      row: row,\n      isCopied: copiedCellIdx === column.idx,\n      isDraggedOver: draggedOverCellIdx === column.idx,\n      isCellSelected: isCellSelected,\n      dragHandleProps: isCellSelected ? selectedCellProps.dragHandleProps : undefined,\n      onFocus: isCellSelected ? selectedCellProps.onFocus : undefined,\n      onKeyDown: isCellSelected ? selectedCellProps.onKeyDown : undefined,\n      onRowClick: onRowClick,\n      onRowChange: onRowChange,\n      selectCell: selectCell\n    }, column.key));\n  }\n\n  return /*#__PURE__*/jsx(RowSelectionProvider, {\n    value: isRowSelected,\n    children: /*#__PURE__*/jsx(\"div\", {\n      role: \"row\",\n      ref: ref,\n      className: className,\n      onMouseEnter: handleDragEnter,\n      style: {\n        top,\n        '--row-height': `${height}px`\n      },\n      ...props,\n      children: cells\n    })\n  });\n}\n\nconst Row$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Row));\n\nfunction GroupCell({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  column,\n  groupColumnIndex,\n  toggleGroup: toggleGroupWrapper\n}) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    className: getCellClassname(column),\n    style: { ...getCellStyle(column),\n      cursor: isLevelMatching ? 'pointer' : 'default'\n    },\n    onClick: isLevelMatching ? toggleGroup : undefined,\n    children: (!column.rowGroup || groupColumnIndex === column.idx) && column.groupFormatter && /*#__PURE__*/jsx(column.groupFormatter, {\n      rowIdx: rowIdx,\n      groupKey: groupKey,\n      childRows: childRows,\n      column: column,\n      isExpanded: isExpanded,\n      isCellSelected: isCellSelected,\n      toggleGroup: toggleGroup\n    })\n  }, column.key);\n}\n\nconst GroupCell$1 = /*#__PURE__*/memo(GroupCell);\n\nfunction GroupedRow({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  height,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  toggleGroup,\n  ...props\n}) {\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({\n      rowIdx,\n      idx: -1\n    });\n  }\n\n  return /*#__PURE__*/jsx(RowSelectionProvider, {\n    value: isRowSelected,\n    children: /*#__PURE__*/jsx(\"div\", {\n      role: \"row\",\n      \"aria-level\": level,\n      \"aria-expanded\": isExpanded,\n      className: clsx(rowClassname, groupRowClassname, `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, selectedCellIdx === -1 && groupRowSelectedClassname),\n      onClick: selectGroup,\n      style: {\n        top,\n        '--row-height': `${height}px`\n      },\n      ...props,\n      children: viewportColumns.map(column => /*#__PURE__*/jsx(GroupCell$1, {\n        id: id,\n        rowIdx: rowIdx,\n        groupKey: groupKey,\n        childRows: childRows,\n        isExpanded: isExpanded,\n        isCellSelected: selectedCellIdx === column.idx,\n        column: column,\n        groupColumnIndex: idx,\n        toggleGroup: toggleGroup\n      }, column.key))\n    })\n  });\n}\n\nconst GroupRowRenderer = /*#__PURE__*/memo(GroupedRow);\n\nfunction SummaryCell({\n  column,\n  colSpan,\n  row\n}) {\n  const {\n    summaryFormatter: SummaryFormatter,\n    summaryCellClass\n  } = column;\n  const className = getCellClassname(column, typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-colspan\": colSpan,\n    className: className,\n    style: getCellStyle(column, colSpan),\n    children: SummaryFormatter && /*#__PURE__*/jsx(SummaryFormatter, {\n      column: column,\n      row: row\n    })\n  });\n}\n\nconst SummaryCell$1 = /*#__PURE__*/memo(SummaryCell);\n\nfunction SummaryRow({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  lastFrozenColumnIndex,\n  'aria-rowindex': ariaRowIndex\n}) {\n  const cells = [];\n\n  for (let index = 0; index < viewportColumns.length; index++) {\n    const column = viewportColumns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n      type: 'SUMMARY',\n      row\n    });\n\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    cells.push( /*#__PURE__*/jsx(SummaryCell$1, {\n      column: column,\n      colSpan: colSpan,\n      row: row\n    }, column.key));\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": ariaRowIndex,\n    className: `${rowClassname} rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'} ${summaryRowClassname}`,\n    style: {\n      bottom\n    },\n    children: cells\n  });\n}\n\nconst SummaryRow$1 = /*#__PURE__*/memo(SummaryRow);\n\nvar _globalThis$document;\n\nconst body = (_globalThis$document = globalThis.document) == null ? void 0 : _globalThis$document.body;\nconst initialPosition = {\n  idx: -1,\n  rowIdx: -1,\n  mode: 'SELECT'\n};\n\nfunction DataGrid({\n  columns: rawColumns,\n  rows: rawRows,\n  summaryRows,\n  rowKeyGetter,\n  onRowsChange,\n  rowHeight,\n  headerRowHeight: rawHeaderRowHeight,\n  summaryRowHeight: rawSummaryRowHeight,\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumns,\n  onSortColumnsChange,\n  defaultColumnOptions,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  rowRenderer,\n  emptyRowsRenderer: EmptyRowsRenderer,\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onFill,\n  onPaste,\n  cellNavigationMode: rawCellNavigationMode,\n  enableVirtualization,\n  editorPortalTarget: rawEditorPortalTarget,\n  className,\n  style,\n  rowClass,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy\n}, ref) {\n  var _rowHeight, _enableVirtualization, _summaryRows$length;\n\n  (_rowHeight = rowHeight) != null ? _rowHeight : rowHeight = 35;\n  const headerRowHeight = rawHeaderRowHeight != null ? rawHeaderRowHeight : typeof rowHeight === 'number' ? rowHeight : 35;\n  const summaryRowHeight = rawSummaryRowHeight != null ? rawSummaryRowHeight : typeof rowHeight === 'number' ? rowHeight : 35;\n  const RowRenderer = rowRenderer != null ? rowRenderer : Row$1;\n  const cellNavigationMode = rawCellNavigationMode != null ? rawCellNavigationMode : 'NONE';\n  (_enableVirtualization = enableVirtualization) != null ? _enableVirtualization : enableVirtualization = true;\n  const editorPortalTarget = rawEditorPortalTarget != null ? rawEditorPortalTarget : body;\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState(initialPosition);\n  const [copiedCell, setCopiedCell] = useState(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState(undefined);\n  const focusSinkRef = useRef(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(updateRow);\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = 1;\n  const summaryRowsCount = (_summaryRows$length = summaryRows == null ? void 0 : summaryRows.length) != null ? _summaryRows$length : 0;\n  const clientHeight = gridHeight - headerRowHeight - summaryRowsCount * summaryRowHeight;\n  const isSelectable = selectedRows != null && onSelectedRowsChange != null;\n  const allRowsSelected = useMemo(() => {\n    const {\n      length\n    } = rawRows;\n    return length !== 0 && selectedRows != null && rowKeyGetter != null && selectedRows.size >= length && rawRows.every(row => selectedRows.has(rowKeyGetter(row)));\n  }, [rawRows, selectedRows, rowKeyGetter]);\n  const {\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useCalculatedColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined,\n    enableVirtualization\n  });\n  const {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    totalRowHeight,\n    isGroupRow,\n    getRowTop,\n    getRowHeight,\n    findRowIdx\n  } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds,\n    enableVirtualization\n  });\n  const viewportColumns = useViewportColumns({\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    lastFrozenColumnIndex,\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    summaryRows,\n    isGroupRow\n  });\n  const hasGroups = groupBy.length > 0 && typeof rowGrouper === 'function';\n  const minColIdx = hasGroups ? -1 : 0;\n  const enableCellDragAndDrop = hasGroups ? false : onFill != null;\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) {\n      return;\n    }\n\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n\n    focusSinkRef.current.focus({\n      preventScroll: true\n    });\n  });\n  useImperativeHandle(ref, () => ({\n    element: gridRef.current,\n\n    scrollToColumn(idx) {\n      scrollToCell({\n        idx\n      });\n    },\n\n    scrollToRow(rowIdx) {\n      const {\n        current\n      } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: getRowTop(rowIdx),\n        behavior: 'smooth'\n      });\n    },\n\n    selectCell\n  }));\n  const handleColumnResize = useCallback((column, width) => {\n    setColumnWidths(columnWidths => {\n      const newColumnWidths = new Map(columnWidths);\n      newColumnWidths.set(column.key, width);\n      return newColumnWidths;\n    });\n    onColumnResize == null ? void 0 : onColumnResize(column.idx, width);\n  }, [onColumnResize]);\n  const setDraggedOverRowIdx = useCallback(rowIdx => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  function selectRow({\n    rowIdx,\n    checked,\n    isShiftClick\n  }) {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = sign(rowIdx - previousRowIdx);\n\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function onGridFocus() {\n    if (!isCellWithinBounds(selectedPosition)) {\n      const initialPosition = {\n        idx: 0,\n        rowIdx: 0,\n        mode: 'SELECT'\n      };\n\n      if (isCellWithinBounds(initialPosition)) {\n        setSelectedPosition(initialPosition);\n      }\n    } else {\n      scrollToCell(selectedPosition);\n    }\n  }\n\n  function handleKeyDown(event) {\n    const {\n      key,\n      keyCode\n    } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (onPaste && isCtrlKeyHeldDown(event) && isCellWithinBounds(selectedPosition) && !isGroupRow(row) && selectedPosition.idx !== -1 && selectedPosition.mode === 'SELECT') {\n      const cKey = 67;\n      const vKey = 86;\n\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (isCellWithinBounds(selectedPosition) && isGroupRow(row) && selectedPosition.idx === -1 && (key === 'ArrowLeft' && row.isExpanded || key === 'ArrowRight' && !row.isExpanded)) {\n      event.preventDefault();\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event) {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll == null ? void 0 : onScroll(event);\n  }\n\n  function getRawRowIdx(rowIdx) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx]) : rowIdx;\n  }\n\n  function updateRow(rowIdx, row) {\n    if (typeof onRowsChange !== 'function') return;\n    if (row === rawRows[rowIdx]) return;\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = row;\n    onRowsChange(updatedRows, {\n      indexes: [rowIdx],\n      column: columns[selectedPosition.idx]\n    });\n  }\n\n  function commitEditorChanges() {\n    var _columns$selectedPosi;\n\n    if (((_columns$selectedPosi = columns[selectedPosition.idx]) == null ? void 0 : _columns$selectedPosi.editor) == null || selectedPosition.mode === 'SELECT' || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    const rowIdx = getRawRowIdx(selectedPosition.rowIdx);\n    updateRow(rowIdx, selectedPosition.row);\n  }\n\n  function handleCopy() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    setCopiedCell({\n      row: rawRows[getRawRowIdx(rowIdx)],\n      columnKey: columns[idx].key\n    });\n  }\n\n  function handlePaste() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n\n    if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n    updateRow(rowIdx, updatedTargetRow);\n  }\n\n  function handleCellInput(event) {\n    var _column$editorOptions;\n\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const {\n      key\n    } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        commitEditorChanges();\n        closeEditor();\n      }\n\n      return;\n    }\n\n    (_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.onCellKeyDown == null ? void 0 : _column$editorOptions.onCellKeyDown(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({\n        idx,\n        rowIdx\n      }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({\n      columnKey: column.key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n    const indexes = [];\n\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      const targetRowIdx = i - startRowIndex;\n\n      if (updatedRows[i] !== updatedTargetRows[targetRowIdx]) {\n        updatedRows[i] = updatedTargetRows[targetRowIdx];\n        indexes.push(i);\n      }\n    }\n\n    if (indexes.length > 0) {\n      onRowsChange(updatedRows, {\n        indexes,\n        column\n      });\n    }\n\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event) {\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({\n      columnKey: column.key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n    const indexes = [];\n\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      const targetRowIdx = i - rowIdx - 1;\n\n      if (updatedRows[i] !== updatedTargetRows[targetRowIdx]) {\n        updatedRows[i] = updatedTargetRows[targetRowIdx];\n        indexes.push(i);\n      }\n    }\n\n    if (indexes.length > 0) {\n      onRowsChange(updatedRows, {\n        indexes,\n        column\n      });\n    }\n  }\n\n  function handleEditorRowChange(row, commitChanges) {\n    if (selectedPosition.mode === 'SELECT') return;\n\n    if (commitChanges) {\n      updateRow(getRawRowIdx(selectedPosition.rowIdx), row);\n      closeEditor();\n    } else {\n      setSelectedPosition(position => ({ ...position,\n        row\n      }));\n    }\n  }\n\n  function handleOnClose(commitChanges) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n\n    closeEditor();\n  }\n\n  function isCellWithinBounds({\n    idx,\n    rowIdx\n  }) {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position) {\n    return isCellWithinBounds(position) && isSelectedCellEditable({\n      columns,\n      rows,\n      selectedPosition: position,\n      isGroupRow\n    });\n  }\n\n  function selectCell(position, enableEditor) {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx];\n      setSelectedPosition({ ...position,\n        mode: 'EDIT',\n        key: null,\n        row,\n        originalRow: row\n      });\n    } else {\n      setSelectedPosition({ ...position,\n        mode: 'SELECT'\n      });\n    }\n\n    onSelectedCellChange == null ? void 0 : onSelectedCellChange({ ...position\n    });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({\n      idx,\n      rowIdx\n    }) => ({\n      idx,\n      rowIdx,\n      mode: 'SELECT'\n    }));\n  }\n\n  function scrollToCell({\n    idx,\n    rowIdx\n  }) {\n    const {\n      current\n    } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      var _rowIdx;\n\n      (_rowIdx = rowIdx) != null ? _rowIdx : rowIdx = selectedPosition.rowIdx;\n      if (!isCellWithinBounds({\n        rowIdx,\n        idx\n      })) return;\n      const {\n        clientWidth\n      } = current;\n      const column = columns[idx];\n      const {\n        left,\n        width\n      } = columnMetrics.get(column);\n      let right = left + width;\n      const row = rows[rowIdx];\n\n      if (!isGroupRow(row)) {\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n          type: 'ROW',\n          row\n        });\n\n        if (colSpan !== undefined) {\n          const {\n            left,\n            width\n          } = columnMetrics.get(columns[column.idx + colSpan - 1]);\n          right = left + width;\n        }\n      }\n\n      const isCellAtLeftBoundary = left < scrollLeft + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = right > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary) {\n        current.scrollLeft = left - totalFrozenColumnWidth;\n      } else if (isCellAtRightBoundary) {\n        current.scrollLeft = right - clientWidth;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      const rowTop = getRowTop(rowIdx);\n      const rowHeight = getRowHeight(rowIdx);\n\n      if (rowTop < scrollTop) {\n        current.scrollTop = rowTop;\n      } else if (rowTop + rowHeight > scrollTop + clientHeight) {\n        current.scrollTop = rowTop + rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key, ctrlKey, shiftKey) {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    if (key === 'ArrowLeft' && isRowSelected && isGroupRow(row) && !row.isExpanded && row.level !== 0) {\n      let parentRowIdx = -1;\n\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n\n      if (parentRowIdx !== -1) {\n        return {\n          idx,\n          rowIdx: parentRowIdx\n        };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return {\n          idx,\n          rowIdx: rowIdx - 1\n        };\n\n      case 'ArrowDown':\n        return {\n          idx,\n          rowIdx: rowIdx + 1\n        };\n\n      case 'ArrowLeft':\n        return {\n          idx: idx - 1,\n          rowIdx\n        };\n\n      case 'ArrowRight':\n        return {\n          idx: idx + 1,\n          rowIdx\n        };\n\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? {\n            idx: columns.length - 1,\n            rowIdx: rows.length - 1\n          } : {\n            idx: 0,\n            rowIdx: 0\n          };\n        }\n\n        return {\n          idx: idx + (shiftKey ? -1 : 1),\n          rowIdx\n        };\n\n      case 'Home':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: 0\n        };\n        return ctrlKey ? {\n          idx: 0,\n          rowIdx: 0\n        } : {\n          idx: 0,\n          rowIdx\n        };\n\n      case 'End':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: rows.length - 1\n        };\n        return ctrlKey ? {\n          idx: columns.length - 1,\n          rowIdx: rows.length - 1\n        } : {\n          idx: columns.length - 1,\n          rowIdx\n        };\n\n      case 'PageUp':\n        {\n          const nextRowY = getRowTop(rowIdx) + getRowHeight(rowIdx) - clientHeight;\n          return {\n            idx,\n            rowIdx: nextRowY > 0 ? findRowIdx(nextRowY) : 0\n          };\n        }\n\n      case 'PageDown':\n        {\n          const nextRowY = getRowTop(rowIdx) + clientHeight;\n          return {\n            idx,\n            rowIdx: nextRowY < totalRowHeight ? findRowIdx(nextRowY) : rows.length - 1\n          };\n        }\n\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event) {\n    if (selectedPosition.mode === 'EDIT') {\n      var _columns$selectedPosi2, _columns$selectedPosi3;\n\n      const onNavigation = (_columns$selectedPosi2 = (_columns$selectedPosi3 = columns[selectedPosition.idx].editorOptions) == null ? void 0 : _columns$selectedPosi3.onNavigation) != null ? _columns$selectedPosi2 : onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n\n    const {\n      key,\n      shiftKey\n    } = event;\n    let mode = cellNavigationMode;\n\n    if (key === 'Tab') {\n      if (canExitGrid({\n        shiftKey,\n        cellNavigationMode,\n        columns,\n        rowsCount: rows.length,\n        selectedPosition\n      })) {\n        commitEditorChanges();\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE' ? 'CHANGE_ROW' : cellNavigationMode;\n    }\n\n    event.preventDefault();\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    const nextPosition = getNextSelectedCellPosition({\n      columns,\n      colSpanColumns,\n      rows,\n      lastFrozenColumnIndex,\n      cellNavigationMode: mode,\n      currentPosition: selectedPosition,\n      nextPosition: getNextPosition(key, ctrlKey, shiftKey),\n      isCellWithinBounds,\n      isGroupRow\n    });\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx) {\n    if (draggedOverRowIdx === undefined) return;\n    const {\n      rowIdx\n    } = selectedPosition;\n    const isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx) {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition) ? {\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n      } : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = getRowTop(rowIdx) + headerRowHeight;\n\n      if (isGroupRow(row)) {\n        ({\n          startRowIndex\n        } = row);\n        const isGroupRowSelected = isSelectable && row.childRows.every(cr => selectedRows == null ? void 0 : selectedRows.has(rowKeyGetter(cr)));\n        rowElements.push( /*#__PURE__*/jsx(GroupRowRenderer, {\n          \"aria-level\": row.level + 1,\n          \"aria-setsize\": row.setSize,\n          \"aria-posinset\": row.posInSet + 1,\n          \"aria-rowindex\": headerRowsCount + startRowIndex + 1,\n          \"aria-selected\": isSelectable ? isGroupRowSelected : undefined,\n          id: row.id,\n          groupKey: row.groupKey,\n          viewportColumns: viewportColumns,\n          childRows: row.childRows,\n          rowIdx: rowIdx,\n          top: top,\n          height: getRowHeight(rowIdx),\n          level: row.level,\n          isExpanded: row.isExpanded,\n          selectedCellIdx: selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined,\n          isRowSelected: isGroupRowSelected,\n          onFocus: selectedPosition.rowIdx === rowIdx ? handleFocus : undefined,\n          onKeyDown: selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined,\n          selectCell: selectCellWrapper,\n          toggleGroup: toggleGroupWrapper\n        }, row.id));\n        continue;\n      }\n\n      startRowIndex++;\n      let key;\n      let isRowSelected = false;\n\n      if (typeof rowKeyGetter === 'function') {\n        var _selectedRows$has;\n\n        key = rowKeyGetter(row);\n        isRowSelected = (_selectedRows$has = selectedRows == null ? void 0 : selectedRows.has(key)) != null ? _selectedRows$has : false;\n      } else {\n        key = hasGroups ? startRowIndex : rowIdx;\n      }\n\n      rowElements.push( /*#__PURE__*/jsx(RowRenderer, {\n        \"aria-rowindex\": headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1,\n        \"aria-selected\": isSelectable ? isRowSelected : undefined,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick,\n        rowClass: rowClass,\n        top: top,\n        height: getRowHeight(rowIdx),\n        copiedCellIdx: copiedCell !== null && copiedCell.row === row ? columns.findIndex(c => c.key === copiedCell.columnKey) : undefined,\n        draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n        setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n        lastFrozenColumnIndex: lastFrozenColumnIndex,\n        selectedCellProps: getSelectedCellProps(rowIdx),\n        onRowChange: handleFormatterRowChangeWrapper,\n        selectCell: selectCellWrapper\n      }, key));\n    }\n\n    return rowElements;\n  }\n\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition(initialPosition);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    closeEditor();\n  }\n\n  return /*#__PURE__*/jsxs(\"div\", {\n    role: hasGroups ? 'treegrid' : 'grid',\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-multiselectable\": isSelectable ? true : undefined,\n    \"aria-colcount\": columns.length,\n    \"aria-rowcount\": headerRowsCount + rowsCount + summaryRowsCount,\n    className: clsx(rootClassname, className, isDragging && viewportDraggingClassname),\n    style: { ...style,\n      '--header-row-height': `${headerRowHeight}px`,\n      '--row-width': `${totalColumnWidth}px`,\n      '--summary-row-height': `${summaryRowHeight}px`,\n      ...layoutCssVars\n    },\n    ref: gridRef,\n    onScroll: handleScroll,\n    children: [/*#__PURE__*/jsx(HeaderRow$1, {\n      rowKeyGetter: rowKeyGetter,\n      rows: rawRows,\n      columns: viewportColumns,\n      onColumnResize: handleColumnResize,\n      allRowsSelected: allRowsSelected,\n      onSelectedRowsChange: onSelectedRowsChange,\n      sortColumns: sortColumns,\n      onSortColumnsChange: onSortColumnsChange,\n      lastFrozenColumnIndex: lastFrozenColumnIndex\n    }), rows.length === 0 && EmptyRowsRenderer ? /*#__PURE__*/jsx(EmptyRowsRenderer, {}) : /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(\"div\", {\n        ref: focusSinkRef,\n        tabIndex: 0,\n        className: focusSinkClassname,\n        onKeyDown: handleKeyDown,\n        onFocus: onGridFocus\n      }), /*#__PURE__*/jsx(\"div\", {\n        style: {\n          height: max(totalRowHeight, clientHeight)\n        }\n      }), /*#__PURE__*/jsx(RowSelectionChangeProvider, {\n        value: selectRowWrapper,\n        children: getViewportRows()\n      }), summaryRows == null ? void 0 : summaryRows.map((row, rowIdx) => /*#__PURE__*/jsx(SummaryRow$1, {\n        \"aria-rowindex\": headerRowsCount + rowsCount + rowIdx + 1,\n        rowIdx: rowIdx,\n        row: row,\n        bottom: summaryRowHeight * (summaryRows.length - 1 - rowIdx),\n        viewportColumns: viewportColumns,\n        lastFrozenColumnIndex: lastFrozenColumnIndex\n      }, rowIdx))]\n    })]\n  });\n}\n\nconst DataGrid$1 = /*#__PURE__*/forwardRef(DataGrid);\nvar css_248z = \".t16y9g8l700-canary49{appearance:none;box-sizing:border-box;width:100%;height:100%;padding:0 6px;border:2px solid #ccc;vertical-align:top;color:var(--color);background-color:var(--background-color);font-family:inherit;font-size:var(--font-size)}.t16y9g8l700-canary49:focus{border-color:var(--selection-color);outline:none}.t16y9g8l700-canary49::placeholder{color:#999;opacity:1}\";\nstyleInject(css_248z);\nconst textEditor = \"t16y9g8l700-canary49\";\nconst textEditorClassname = `rdg-text-editor ${textEditor}`;\n\nfunction autoFocusAndSelect(input) {\n  input == null ? void 0 : input.focus();\n  input == null ? void 0 : input.select();\n}\n\nfunction TextEditor({\n  row,\n  column,\n  onRowChange,\n  onClose\n}) {\n  return /*#__PURE__*/jsx(\"input\", {\n    className: textEditorClassname,\n    ref: autoFocusAndSelect,\n    value: row[column.key],\n    onChange: event => onRowChange({ ...row,\n      [column.key]: event.target.value\n    }),\n    onBlur: () => onClose(true)\n  });\n}\n\nexport default DataGrid$1;\nexport { Cell$1 as Cell, Row$1 as Row, SELECT_COLUMN_KEY, SelectCellFormatter, SelectColumn, SortableHeaderCell, TextEditor, ToggleGroupFormatter, ValueFormatter, useRowSelection };","map":{"version":3,"sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/style/cell.ts","../src/style/core.ts","../src/style/grouprow.ts","../src/style/header.ts","../src/style/row.ts","../src/hooks/useFocusRef.ts","../src/formatters/SelectCellFormatter.tsx","../src/formatters/ValueFormatter.tsx","../src/formatters/ToggleGroupFormatter.tsx","../src/utils/colSpanUtils.ts","../src/utils/domUtils.ts","../src/utils/keyboardUtils.ts","../src/utils/selectedCellUtils.ts","../src/utils/index.ts","../src/Columns.tsx","../src/hooks/useCalculatedColumns.ts","../src/hooks/useGridDimensions.ts","../src/hooks/useLatestFunc.ts","../src/hooks/useRowSelection.ts","../src/hooks/useViewportColumns.ts","../src/hooks/useViewportRows.ts","../src/headerCells/SortableHeaderCell.tsx","../src/HeaderCell.tsx","../src/HeaderRow.tsx","../src/Cell.tsx","../src/EditCell.tsx","../src/Row.tsx","../src/GroupCell.tsx","../src/GroupRow.tsx","../src/SummaryCell.tsx","../src/SummaryRow.tsx","../src/DataGrid.tsx","../src/editors/TextEditor.tsx"],"names":["cell","cellClassname","cellFrozen","cellFrozenClassname","cellFrozenLast","cellFrozenLastClassname","root","rootClassname","focusSink","focusSinkClassname","viewportDragging","viewportDraggingClassname","groupRow","groupRowClassname","groupRowSelected","groupRowSelectedClassname","headerRow","headerRowClassname","row","rowClassname","summaryRow","summaryRowClassname","ref","useRef","useLayoutEffect","preventScroll","checkboxLabel","checkboxLabelClassname","checkboxInput","checkboxInputClassname","checkbox","checkboxClassname","checkboxLabelDisabled","checkboxLabelDisabledClassname","ariaLabelledBy","inputRef","useFocusRef","handleChange","e","onChange","clsx","disabled","onClick","props","groupCellContent","groupCellContentClassname","caret","caretClassname","toggleGroup","cellRef","handleKeyDown","key","d","isExpanded","colSpan","column","Number","event","nonInputKeys","target","isGroupRow","columns","selectedPosition","rows","isCellEditable","rowsCount","position","setColSpan","moveRight","posIdx","colIdx","getColSpan","type","isCellWithinBounds","currentPosition","cellNavigationMode","rowIdx","columnsCount","isAfterLastColumn","idx","isBeforeFirstColumn","isLastRow","isFirstRow","shiftKey","atLastCellInRow","atFirstCellInRow","atLastRow","atFirstRow","sign","gridColumnStart","gridColumnEnd","left","undefined","SELECT_COLUMN_KEY","useRowSelection","onRowSelectionChange","isShiftClick","checked","stopPropagation","SelectColumn","name","width","maxWidth","resizable","sortable","frozen","headerRenderer","onAllRowsSelectionChange","formatter","groupFormatter","SelectGroupFormatter","enableVirtualization","minColumnWidth","defaultColumnOptions","defaultFormatter","defaultSortable","defaultResizable","groupBy","useMemo","lastFrozenColumnIndex","rawColumn","rowGroup","rawGroupBy","isLastFrozenColumn","frozenA","frozenB","aKey","bKey","colSpanColumns","columnMetrics","totalColumnWidth","totalFrozenColumnWidth","templateColumns","allocatedWidth","unassignedColumnsCount","getSpecifiedWidth","clampColumnWidth","unallocatedWidth","viewportWidth","unallocatedColumnWidth","columnMetric","layoutCssVars","i","viewportLeft","scrollLeft","viewportRight","lastColIdx","firstUnfrozenColumnIdx","min","colVisibleStartIdx","colVisibleEndIdx","colOverscanStartIdx","max","colOverscanEndIdx","columnWidths","floor","parseInt","minWidth","gridRef","useState","ResizeObserver","resizeObserver","clientHeight","setGridWidth","clientWidth","devicePixelRatio","setGridHeight","useEffect","useCallback","RowSelectionContext","createContext","RowSelectionProvider","RowSelectionChangeContext","RowSelectionChangeProvider","rowSelectionContext","useContext","rowSelectionChangeContext","startIdx","updateStartIdx","summaryRows","viewportColumns","RENDER_BATCH_SIZE","Array","rowGrouper","rawRows","groupRows","groupRowsCount","groups","Object","remainingGroupByKeys","childRows","startRowIndex","childRowsCount","allGroupRows","flattenedRows","expandGroup","isReadonlyArray","id","parentId","groupKey","expandedGroupIds","setSize","keys","length","level","findRowIdx","totalRowHeight","rowHeight","getRowTop","getRowHeight","offset","rowPositions","currentRowHeight","top","height","validateRowIdx","start","end","middle","currentOffset","rowOverscanStartIdx","rowOverscanEndIdx","overscanThreshold","rowVisibleStartIdx","rowVisibleEndIdx","scrollTop","ceil","headerSortCell","headerSortCellClassname","headerSortName","headerSortNameClassname","children","sortText","sortDirection","onSort","cellResizable","cellResizableClassname","onSortColumnsChange","onPointerDown","pointerId","right","currentTarget","clientX","onPointerMove","onPointerUp","onResize","window","sortIndex","sortColumns","sort","sortColumn","direction","priority","ariaSort","ctrlClick","sortDescendingFirst","nextSort","columnKey","nextSortColumn","nextSortColumns","getCell","className","getCellClassname","getCellStyle","handleAllRowsSelectionChange","assertIsValidKeyGetter","newSelectedRows","onSelectedRowsChange","cells","index","memo","cellCopied","cellCopiedClassname","cellDraggedOver","cellDraggedOverClassname","cellDragHandle","cellDragHandleClassname","cellClass","isCopied","isDraggedOver","selectCellWrapper","openEditor","selectCell","handleClick","onRowClick","handleContextMenu","onContextMenu","handleDoubleClick","onDoubleClick","handleRowChange","newRow","onRowChange","dragHandleProps","forwardRef","cellEditing","cellEditingClassname","editorPortalTarget","frameRequestRef","commitOnOutsideMouseDown","useLatestFunc","cancelFrameRequest","cancelAnimationFrame","onWindowCaptureMouseDown","requestAnimationFrame","addEventListener","capture","removeEventListener","content","editorOptions","createPortal","setDraggedOverRowIdx","onMouseEnter","rowClass","CellRenderer","cellRenderer","isCellSelected","selectedCellProps","editorProps","copiedCellIdx","draggedOverCellIdx","toggleGroupWrapper","isLevelMatching","groupColumnIndex","cursor","selectedCellIdx","summaryFormatter","summaryCellClass","SummaryFormatter","ariaRowIndex","bottom","body","globalThis","initialPosition","mode","headerRowHeight","summaryRowHeight","emptyRowsRenderer","ariaDescribedBy","rawHeaderRowHeight","rawSummaryRowHeight","RowRenderer","rowRenderer","rawCellNavigationMode","rawEditorPortalTarget","focusSinkRef","prevSelectedPosition","latestDraggedOverRowIdx","lastSelectedRowIdx","isCellFocusable","selectRowWrapper","handleFormatterRowChangeWrapper","useGridDimensions","headerRowsCount","summaryRowsCount","gridHeight","isSelectable","selectedRows","allRowsSelected","rowKeyGetter","useCalculatedColumns","useViewportRows","useViewportColumns","hasGroups","minColIdx","enableCellDragAndDrop","onFill","scrollToCell","useImperativeHandle","element","scrollToColumn","scrollToRow","current","behavior","handleColumnResize","setColumnWidths","newColumnWidths","onColumnResize","setOverRowIdx","rowKey","previousRowIdx","step","newExpandedGroupIds","onExpandedGroupIdsChange","setSelectedPosition","keyCode","onPaste","isCtrlKeyHeldDown","cKey","vKey","handleCopy","handlePaste","setCopiedCell","closeEditor","navigate","handleCellInput","setScrollTop","setScrollLeft","onScroll","updatedRows","onRowsChange","indexes","getRawRowIdx","updateRow","targetRow","copiedCell","updatedTargetRow","sourceRow","sourceColumnKey","targetColumnKey","commitEditorChanges","isDefaultCellInput","originalRow","overRowIdx","endRowIndex","targetRows","updatedTargetRows","targetRowIdx","setDragging","onMouseUp","handleDragEnd","isSelectedCellEditable","enableEditor","onSelectedCellChange","isCellAtLeftBoundary","isCellAtRightBoundary","rowTop","isRowSelected","parentRowIdx","parentRow","ctrlKey","nextRowY","onNavigation","canExitGrid","nextPosition","getNextSelectedCellPosition","getNextPosition","draggedOverRowIdx","currentRowIdx","onKeyDown","onClose","handleOnClose","onFocus","onMouseDown","rowElements","isGroupRowSelected","cr","c","getDraggedOverCellIdx","isDragging","getSelectedCellProps","_jsx","onGridFocus","getViewportRows","textEditor","textEditorClassname","input","value"],"mappings":"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","sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import { css } from '@linaria/core';\n\nexport const cell = css`\n  contain: strict;\n  contain: size layout style paint;\n  padding: 0 8px;\n  border-right: 1px solid var(--border-color);\n  border-bottom: 1px solid var(--border-color);\n  background-color: inherit;\n\n  white-space: nowrap;\n  overflow: hidden;\n  overflow: clip;\n  text-overflow: ellipsis;\n\n  &[aria-selected='true'] {\n    box-shadow: inset 0 0 0 2px var(--selection-color);\n  }\n`;\n\nexport const cellClassname = `rdg-cell ${cell}`;\n\nconst cellFrozen = css`\n  position: sticky;\n  // Should have a higher value than 0 to show up above unfrozen cells\n  z-index: 1;\n`;\n\nexport const cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\n\nexport const cellFrozenLast = css`\n  box-shadow: 2px 0 5px -2px rgba(136, 136, 136, 0.3);\n`;\n\nexport const cellFrozenLastClassname = `rdg-cell-frozen-last ${cellFrozenLast}`;\n","import { css } from '@linaria/core';\nimport { row } from './row';\n\nconst lightTheme = `\n  --color: #000;\n  --border-color: #ddd;\n  --summary-border-color: #aaa;\n  --background-color: hsl(0deg 0% 100%);\n  --header-background-color: hsl(0deg 0% 97.5%);\n  --row-hover-background-color: hsl(0deg 0% 96%);\n  --row-selected-background-color: hsl(207deg 76% 92%);\n  --row-selected-hover-background-color: hsl(207deg 76% 88%);\n\n  --checkbox-color: hsl(207deg 100% 29%);\n  --checkbox-focus-color: hsl(207deg 100% 69%);\n  --checkbox-disabled-border-color: #ccc;\n  --checkbox-disabled-background-color: #ddd;\n`;\n\nconst darkTheme = `\n  --color: #ddd;\n  --border-color: #444;\n  --summary-border-color: #555;\n  --background-color: hsl(0deg 0% 13%);\n  --header-background-color: hsl(0deg 0% 10.5%);\n  --row-hover-background-color: hsl(0deg 0% 9%);\n  --row-selected-background-color: hsl(207deg 76% 42%);\n  --row-selected-hover-background-color: hsl(207deg 76% 38%);\n\n  --checkbox-color: hsl(207deg 100% 79%);\n  --checkbox-focus-color: hsl(207deg 100% 89%);\n  --checkbox-disabled-border-color: #000;\n  --checkbox-disabled-background-color: #333;\n`;\n\nconst root = css`\n  ${lightTheme}\n  --selection-color: #66afe9;\n  --font-size: 14px;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  // We set a stacking context so internal elements don't render on top of external components.\n  contain: strict;\n  contain: size layout style paint;\n  content-visibility: auto;\n  height: 350px;\n  border: 1px solid var(--border-color);\n  box-sizing: border-box;\n  overflow: auto;\n  user-select: none;\n  background-color: var(--background-color);\n  color: var(--color);\n  font-size: var(--font-size);\n\n  // set stacking context in safari\n  @supports not (contain: strict) {\n    position: relative;\n    z-index: 0;\n  }\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: inherit;\n  }\n\n  &.rdg-dark {\n    ${darkTheme}\n  }\n\n  @media (prefers-color-scheme: dark) {\n    &:not(.rdg-light) {\n      ${darkTheme}\n    }\n  }\n`;\n\nexport const rootClassname = `rdg ${root}`;\n\nconst focusSink = css`\n  position: sticky;\n  top: 0;\n  left: 0;\n  height: 0;\n  width: 0;\n  outline: 0;\n`;\n\nexport const focusSinkClassname = `rdg-focus-sink ${focusSink}`;\n\nconst viewportDragging = css`\n  &.${row} {\n    cursor: move;\n  }\n`;\n\nexport const viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\n","import { css } from '@linaria/core';\nimport { cell, cellFrozenLast } from './cell';\n\nconst groupRow = css`\n  &:not([aria-selected='true']) {\n    background-color: var(--header-background-color);\n  }\n\n  > .${cell}:not(:last-child):not(.${cellFrozenLast}) {\n    border-right: none;\n  }\n`;\n\nexport const groupRowClassname = `rdg-group-row ${groupRow}`;\n\nconst groupRowSelected = css`\n  &::after {\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: inset 0 0 0 2px var(--selection-color);\n    pointer-events: none;\n    z-index: 2;\n  }\n\n  > .${cell}:first-child {\n    // preserve left border on the first frozen cell after scrolling to the right\n    box-shadow: inset 2px 0 0 0 var(--selection-color);\n  }\n`;\n\n// TODO: rename class\nexport const groupRowSelectedClassname = `rdg-group-row-selected ${groupRowSelected}`;\n","import { css } from '@linaria/core';\n\nconst headerRow = css`\n  contain: strict;\n  contain: size layout style paint;\n  display: grid;\n  grid-template-columns: var(--template-columns);\n  grid-template-rows: var(--header-row-height);\n  height: var(--header-row-height); // needed on Firefox\n  line-height: var(--header-row-height);\n  width: var(--row-width);\n  position: sticky;\n  top: 0;\n  background-color: var(--header-background-color);\n  font-weight: bold;\n  z-index: 3;\n  touch-action: none;\n`;\n\nexport const headerRowClassname = `rdg-header-row ${headerRow}`;\n","import { css } from '@linaria/core';\nimport { cell } from './cell';\n\nexport const row = css`\n  contain: strict;\n  contain: size layout style paint;\n  display: grid;\n  grid-template-rows: var(--row-height);\n  grid-template-columns: var(--template-columns);\n  position: absolute;\n  left: 0;\n  width: var(--row-width);\n  height: var(--row-height); // needed on Firefox\n  line-height: var(--row-height);\n  background-color: var(--background-color);\n\n  &:hover {\n    background-color: var(--row-hover-background-color);\n  }\n\n  &[aria-selected='true'] {\n    background-color: var(--row-selected-background-color);\n\n    &:hover {\n      background-color: var(--row-selected-hover-background-color);\n    }\n  }\n`;\n\nexport const rowClassname = `rdg-row ${row}`;\n\nconst summaryRow = css`\n  position: sticky;\n  z-index: 3;\n  grid-template-rows: var(--summary-row-height);\n  height: var(--summary-row-height); // needed on Firefox\n  line-height: var(--summary-row-height);\n\n  > .${cell} {\n    border-top: 2px solid var(--summary-border-color);\n  }\n`;\n\nexport const summaryRowClassname = `rdg-summary-row ${summaryRow}`;\n","import { useRef, useLayoutEffect } from 'react';\n\nexport function useFocusRef<T extends HTMLOrSVGElement>(isCellSelected: boolean) {\n  const ref = useRef<T>(null);\n  useLayoutEffect(() => {\n    if (!isCellSelected) return;\n    ref.current?.focus({ preventScroll: true });\n  }, [isCellSelected]);\n\n  return ref;\n}\n","import clsx from 'clsx';\nimport { css } from '@linaria/core';\nimport { useFocusRef } from '../hooks/useFocusRef';\n\nconst checkboxLabel = css`\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  margin-right: 1px; // align checkbox in row group cell\n`;\n\nconst checkboxLabelClassname = `rdg-checkbox-label ${checkboxLabel}`;\n\nconst checkboxInput = css`\n  all: unset;\n  width: 0;\n  margin: 0;\n`;\n\nconst checkboxInputClassname = `rdg-checkbox-input ${checkboxInput}`;\n\nconst checkbox = css`\n  content: '';\n  width: 20px;\n  height: 20px;\n  border: 2px solid var(--border-color);\n  background-color: var(--background-color);\n\n  .${checkboxInput}:checked + & {\n    background-color: var(--checkbox-color);\n    box-shadow: inset 0px 0px 0px 4px var(--background-color);\n  }\n\n  .${checkboxInput}:focus + & {\n    border-color: var(--checkbox-focus-color);\n  }\n`;\n\nconst checkboxClassname = `rdg-checkbox ${checkbox}`;\n\nconst checkboxLabelDisabled = css`\n  cursor: default;\n\n  .${checkbox} {\n    border-color: var(--checkbox-disabled-border-color);\n    background-color: var(--checkbox-disabled-background-color);\n  }\n`;\n\nconst checkboxLabelDisabledClassname = `rdg-checkbox-label-disabled ${checkboxLabelDisabled}`;\n\ntype SharedInputProps = Pick<\n  React.InputHTMLAttributes<HTMLInputElement>,\n  'disabled' | 'tabIndex' | 'onClick' | 'aria-label' | 'aria-labelledby'\n>;\n\ninterface SelectCellFormatterProps extends SharedInputProps {\n  isCellSelected: boolean;\n  value: boolean;\n  onChange: (value: boolean, isShiftClick: boolean) => void;\n}\n\nexport function SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}: SelectCellFormatterProps) {\n  const inputRef = useFocusRef<HTMLInputElement>(isCellSelected);\n\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    onChange(e.target.checked, (e.nativeEvent as MouseEvent).shiftKey);\n  }\n\n  return (\n    <label className={clsx(checkboxLabelClassname, { [checkboxLabelDisabledClassname]: disabled })}>\n      <input\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        tabIndex={tabIndex}\n        ref={inputRef}\n        type=\"checkbox\"\n        className={checkboxInputClassname}\n        disabled={disabled}\n        checked={value}\n        onChange={handleChange}\n        onClick={onClick}\n      />\n      <div className={checkboxClassname} />\n    </label>\n  );\n}\n","import type { FormatterProps } from '../types';\n\nexport function ValueFormatter<R, SR>(props: FormatterProps<R, SR>) {\n  try {\n    return <>{props.row[props.column.key as keyof R]}</>;\n  } catch {\n    return null;\n  }\n}\n","import { css } from '@linaria/core';\nimport type { GroupFormatterProps } from '../types';\nimport { useFocusRef } from '../hooks/useFocusRef';\n\nconst groupCellContent = css`\n  outline: none;\n`;\n\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\n\nconst caret = css`\n  margin-left: 4px;\n  stroke: currentColor;\n  stroke-width: 1.5px;\n  fill: transparent;\n  vertical-align: middle;\n\n  > path {\n    transition: d 0.1s;\n  }\n`;\n\nconst caretClassname = `rdg-caret ${caret}`;\n\nexport function ToggleGroupFormatter<R, SR>({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}: GroupFormatterProps<R, SR>) {\n  const cellRef = useFocusRef<HTMLSpanElement>(isCellSelected);\n\n  function handleKeyDown({ key }: React.KeyboardEvent<HTMLSpanElement>) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n\n  return (\n    <span\n      ref={cellRef}\n      className={groupCellContentClassname}\n      tabIndex={-1}\n      onKeyDown={handleKeyDown}\n    >\n      {groupKey}\n      <svg viewBox=\"0 0 14 8\" width=\"14\" height=\"8\" className={caretClassname}>\n        <path d={d} />\n      </svg>\n    </span>\n  );\n}\n","import type { CalculatedColumn, ColSpanArgs } from '../types';\n\nexport function getColSpan<R, SR>(\n  column: CalculatedColumn<R, SR>,\n  lastFrozenColumnIndex: number,\n  args: ColSpanArgs<R, SR>\n): number | undefined {\n  const colSpan = typeof column.colSpan === 'function' ? column.colSpan(args) : 1;\n  if (\n    Number.isInteger(colSpan) &&\n    colSpan! > 1 &&\n    // ignore colSpan if it spans over both frozen and regular columns\n    (!column.frozen || column.idx + colSpan! - 1 <= lastFrozenColumnIndex)\n  ) {\n    return colSpan!;\n  }\n  return undefined;\n}\n","export function stopPropagation(event: React.SyntheticEvent) {\n  event.stopPropagation();\n}\n","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\nconst nonInputKeys = new Set([\n  // Special keys\n  'Unidentified',\n  // Modifier keys\n  'Alt',\n  'AltGraph',\n  'CapsLock',\n  'Control',\n  'Fn',\n  'FnLock',\n  'Meta',\n  'NumLock',\n  'ScrollLock',\n  'Shift',\n  // Whitespace keys\n  'Tab',\n  // Navigation keys\n  'ArrowDown',\n  'ArrowLeft',\n  'ArrowRight',\n  'ArrowUp',\n  'End',\n  'Home',\n  'PageDown',\n  'PageUp',\n  // Editing\n  'Insert',\n  // UI keys\n  'ContextMenu',\n  'Escape',\n  'Pause',\n  'Play',\n  // Device keys\n  'PrintScreen',\n  // Function keys\n  'F1',\n  // 'F2', /!\\ specifically allowed, do not edit\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'F10',\n  'F11',\n  'F12'\n]);\n\nexport function isCtrlKeyHeldDown(e: React.KeyboardEvent): boolean {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nexport function isDefaultCellInput(event: React.KeyboardEvent<HTMLDivElement>): boolean {\n  return !nonInputKeys.has(event.key);\n}\n\n/**\n * By default, the following navigation keys are enabled while an editor is open, under specific conditions:\n * - Tab:\n *   - The editor must be an <input>, a <textarea>, or a <select> element.\n *   - The editor element must be the only immediate child of the editor container/a label.\n */\nexport function onEditorNavigation({ key, target }: React.KeyboardEvent<HTMLDivElement>): boolean {\n  if (\n    key === 'Tab' &&\n    (target instanceof HTMLInputElement ||\n      target instanceof HTMLTextAreaElement ||\n      target instanceof HTMLSelectElement)\n  ) {\n    return target.matches(\n      '.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child'\n    );\n  }\n  return false;\n}\n","import type { CalculatedColumn, Position, GroupRow, CellNavigationMode } from '../types';\nimport { getColSpan } from './colSpanUtils';\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function isSelectedCellEditable<R, SR>({\n  selectedPosition,\n  columns,\n  rows,\n  isGroupRow\n}: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return !isGroupRow(row) && isCellEditable(column, row);\n}\n\nexport function isCellEditable<R, SR>(column: CalculatedColumn<R, SR>, row: R): boolean {\n  return (\n    column.editor != null &&\n    !column.rowGroup &&\n    (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false\n  );\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  colSpanColumns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  currentPosition: Readonly<Position>;\n  nextPosition: Position;\n  lastFrozenColumnIndex: number;\n  isCellWithinBounds: (position: Position) => boolean;\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({\n  cellNavigationMode,\n  columns,\n  colSpanColumns,\n  rows,\n  currentPosition,\n  nextPosition,\n  lastFrozenColumnIndex,\n  isCellWithinBounds,\n  isGroupRow\n}: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  const rowsCount = rows.length;\n  let position = nextPosition;\n\n  const setColSpan = (moveRight: boolean) => {\n    const row = rows[position.rowIdx];\n    if (!isGroupRow(row)) {\n      // If a cell within the colspan range is selected then move to the\n      // previous or the next cell depending on the navigation direction\n      const posIdx = position.idx;\n      for (const column of colSpanColumns) {\n        const colIdx = column.idx;\n        if (colIdx > posIdx) break;\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, { type: 'ROW', row });\n        if (colSpan && posIdx > colIdx && posIdx < colSpan + colIdx) {\n          position.idx = colIdx + (moveRight ? colSpan : 0);\n          break;\n        }\n      }\n    }\n  };\n\n  if (isCellWithinBounds(position)) {\n    setColSpan(position.idx - currentPosition.idx > 0);\n  }\n\n  if (cellNavigationMode !== 'NONE') {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          position = {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else {\n        position = {\n          rowIdx,\n          idx: 0\n        };\n      }\n      setColSpan(true);\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          position = {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else {\n        position = {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n    setColSpan(false);\n  }\n\n  return position;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n  shiftKey: boolean;\n}\n\nexport function canExitGrid<R, SR>({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  selectedPosition: { rowIdx, idx },\n  shiftKey\n}: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n","import clsx from 'clsx';\n\nimport type { CalculatedColumn } from '../types';\nimport { cellClassname, cellFrozenClassname, cellFrozenLastClassname } from '../style';\n\nexport * from './colSpanUtils';\nexport * from './domUtils';\nexport * from './keyboardUtils';\nexport * from './selectedCellUtils';\n\nexport const { min, max, floor, ceil, sign } = Math;\n\nexport function assertIsValidKeyGetter<R, K extends React.Key>(\n  keyGetter: unknown\n): asserts keyGetter is (row: R) => K {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n\nexport function getCellStyle<R, SR>(\n  column: CalculatedColumn<R, SR>,\n  colSpan?: number\n): React.CSSProperties {\n  return {\n    gridColumnStart: column.idx + 1,\n    gridColumnEnd: colSpan !== undefined ? `span ${colSpan}` : undefined,\n    left: column.frozen ? `var(--frozen-left-${column.key})` : undefined\n  };\n}\n\nexport function getCellClassname<R, SR>(\n  column: CalculatedColumn<R, SR>,\n  ...extraClasses: Parameters<typeof clsx>\n): string {\n  return clsx(\n    cellClassname,\n    {\n      [cellFrozenClassname]: column.frozen,\n      [cellFrozenLastClassname]: column.isLastFrozenColumn\n    },\n    ...extraClasses\n  );\n}\n","import { SelectCellFormatter } from './formatters';\nimport { useRowSelection } from './hooks';\nimport type { Column, FormatterProps, GroupFormatterProps } from './types';\nimport { stopPropagation } from './utils';\n\nexport const SELECT_COLUMN_KEY = 'select-row';\n\nfunction SelectFormatter(props: FormatterProps<unknown>) {\n  const [isRowSelected, onRowSelectionChange] = useRowSelection();\n\n  return (\n    <SelectCellFormatter\n      aria-label=\"Select\"\n      tabIndex={-1}\n      isCellSelected={props.isCellSelected}\n      value={isRowSelected}\n      onClick={stopPropagation}\n      onChange={(checked, isShiftClick) => {\n        onRowSelectionChange({ rowIdx: props.rowIdx, checked, isShiftClick });\n      }}\n    />\n  );\n}\n\nfunction SelectGroupFormatter(props: GroupFormatterProps<unknown>) {\n  const [isRowSelected, onRowSelectionChange] = useRowSelection();\n\n  return (\n    <SelectCellFormatter\n      aria-label=\"Select Group\"\n      tabIndex={-1}\n      isCellSelected={props.isCellSelected}\n      value={isRowSelected}\n      onChange={(checked) => {\n        onRowSelectionChange({ checked, isShiftClick: false, rowIdx: props.rowIdx });\n      }}\n      // Stop propagation to prevent row selection\n      onClick={stopPropagation}\n    />\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const SelectColumn: Column<any, any> = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n  headerRenderer(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select All\"\n        isCellSelected={false}\n        value={props.allRowsSelected}\n        onChange={props.onAllRowsSelectionChange}\n      />\n    );\n  },\n  formatter: SelectFormatter,\n  groupFormatter: SelectGroupFormatter\n};\n","import { useMemo } from 'react';\n\nimport type { CalculatedColumn, Column, ColumnMetric } from '../types';\nimport type { DataGridProps } from '../DataGrid';\nimport { ValueFormatter, ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\nimport { floor, max, min } from '../utils';\n\ninterface CalculatedColumnsArgs<R, SR> extends Pick<DataGridProps<R, SR>, 'defaultColumnOptions'> {\n  rawColumns: readonly Column<R, SR>[];\n  rawGroupBy: readonly string[] | undefined | null;\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n  enableVirtualization: boolean;\n}\n\nexport function useCalculatedColumns<R, SR>({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy,\n  enableVirtualization\n}: CalculatedColumnsArgs<R, SR>) {\n  const minColumnWidth = defaultColumnOptions?.minWidth ?? 80;\n  const defaultFormatter = defaultColumnOptions?.formatter ?? ValueFormatter;\n  const defaultSortable = defaultColumnOptions?.sortable ?? false;\n  const defaultResizable = defaultColumnOptions?.resizable ?? false;\n\n  const { columns, colSpanColumns, lastFrozenColumnIndex, groupBy } = useMemo(() => {\n    // Filter rawGroupBy and ignore keys that do not match the columns prop\n    const groupBy: string[] = [];\n    let lastFrozenColumnIndex = -1;\n\n    const columns = rawColumns.map((rawColumn) => {\n      const rowGroup = rawGroupBy?.includes(rawColumn.key) ?? false;\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      const frozen = rowGroup || rawColumn.frozen || false;\n\n      const column: CalculatedColumn<R, SR> = {\n        ...rawColumn,\n        idx: 0,\n        frozen,\n        isLastFrozenColumn: false,\n        rowGroup,\n        sortable: rawColumn.sortable ?? defaultSortable,\n        resizable: rawColumn.resizable ?? defaultResizable,\n        formatter: rawColumn.formatter ?? defaultFormatter\n      };\n\n      if (rowGroup) {\n        column.groupFormatter ??= ToggleGroupFormatter;\n      }\n\n      if (frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n\n    columns.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB }) => {\n      // Sort select column first:\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      // Sort grouped columns second, following the groupBy order:\n      if (rawGroupBy?.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n        return -1;\n      }\n      if (rawGroupBy?.includes(bKey)) return 1;\n\n      // Sort frozen columns third:\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n      if (frozenB) return 1;\n\n      // Sort other columns last:\n      return 0;\n    });\n\n    const colSpanColumns: CalculatedColumn<R, SR>[] = [];\n    columns.forEach((column, idx) => {\n      column.idx = idx;\n\n      if (column.rowGroup) {\n        groupBy.push(column.key);\n      }\n\n      if (column.colSpan != null) {\n        colSpanColumns.push(column);\n      }\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      columns[lastFrozenColumnIndex].isLastFrozenColumn = true;\n    }\n\n    return {\n      columns,\n      colSpanColumns,\n      lastFrozenColumnIndex,\n      groupBy\n    };\n  }, [rawColumns, defaultFormatter, defaultResizable, defaultSortable, rawGroupBy]);\n\n  const { layoutCssVars, totalColumnWidth, totalFrozenColumnWidth, columnMetrics } = useMemo(() => {\n    const columnMetrics = new Map<CalculatedColumn<R, SR>, ColumnMetric>();\n    let left = 0;\n    let totalColumnWidth = 0;\n    let totalFrozenColumnWidth = 0;\n    let templateColumns = '';\n    let allocatedWidth = 0;\n    let unassignedColumnsCount = 0;\n\n    for (const column of columns) {\n      let width = getSpecifiedWidth(column, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, column, minColumnWidth);\n        allocatedWidth += width;\n        columnMetrics.set(column, { width, left: 0 });\n      }\n    }\n\n    const unallocatedWidth = viewportWidth - allocatedWidth;\n    const unallocatedColumnWidth = unallocatedWidth / unassignedColumnsCount;\n\n    for (const column of columns) {\n      let width: number;\n      if (columnMetrics.has(column)) {\n        const columnMetric = columnMetrics.get(column)!;\n        columnMetric.left = left;\n        ({ width } = columnMetric);\n      } else {\n        width = clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n        columnMetrics.set(column, { width, left });\n      }\n      totalColumnWidth += width;\n      left += width;\n      templateColumns += `${width}px `;\n    }\n\n    if (lastFrozenColumnIndex !== -1) {\n      const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex])!;\n      totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n    }\n\n    const layoutCssVars: Record<string, string> = {\n      '--template-columns': templateColumns\n    };\n\n    for (let i = 0; i <= lastFrozenColumnIndex; i++) {\n      const column = columns[i];\n      layoutCssVars[`--frozen-left-${column.key}`] = `${columnMetrics.get(column)!.left}px`;\n    }\n\n    return { layoutCssVars, totalColumnWidth, totalFrozenColumnWidth, columnMetrics };\n  }, [columnWidths, columns, viewportWidth, minColumnWidth, lastFrozenColumnIndex]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    if (!enableVirtualization) {\n      return [0, columns.length - 1];\n    }\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    // get first and last non-frozen column indexes\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    // get the first visible non-frozen column index\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n    while (colVisibleStartIdx < lastColIdx) {\n      const { left, width } = columnMetrics.get(columns[colVisibleStartIdx])!;\n      // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n      if (left + width > viewportLeft) {\n        break;\n      }\n      colVisibleStartIdx++;\n    }\n\n    // get the last visible non-frozen column index\n    let colVisibleEndIdx = colVisibleStartIdx;\n    while (colVisibleEndIdx < lastColIdx) {\n      const { left, width } = columnMetrics.get(columns[colVisibleEndIdx])!;\n      // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n      if (left + width >= viewportRight) {\n        break;\n      }\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = min(lastColIdx, colVisibleEndIdx + 1);\n\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [\n    columnMetrics,\n    columns,\n    lastFrozenColumnIndex,\n    scrollLeft,\n    totalFrozenColumnWidth,\n    viewportWidth,\n    enableVirtualization\n  ]);\n\n  return {\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return floor((viewportWidth * parseInt(width, 10)) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return min(width, maxWidth);\n  }\n\n  return width;\n}\n","import { useRef, useState, useLayoutEffect } from 'react';\n\nexport function useGridDimensions(): [\n  ref: React.RefObject<HTMLDivElement>,\n  width: number,\n  height: number\n] {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n\n  useLayoutEffect(() => {\n    const { ResizeObserver } = window;\n\n    // don't break in jest/jsdom and browsers that don't support ResizeObserver\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (ResizeObserver == null) return;\n\n    const resizeObserver = new ResizeObserver(() => {\n      // Get dimensions without scrollbars.\n      // The dimensions given by the callback entries in Firefox do not substract the scrollbar sizes.\n      const { clientWidth, clientHeight } = gridRef.current!;\n      // TODO: remove once fixed upstream\n      // we reduce width by 1px here to avoid layout issues in Chrome\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1206298\n      setGridWidth(clientWidth - (devicePixelRatio % 0.5 === 0 ? 0 : 1));\n      setGridHeight(clientHeight);\n    });\n\n    resizeObserver.observe(gridRef.current!);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  return [gridRef, gridWidth, gridHeight];\n}\n","import { useRef, useEffect, useCallback } from 'react';\n\n// https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useLatestFunc<T extends (...args: any[]) => any>(fn: T) {\n  const ref = useRef(fn);\n\n  useEffect(() => {\n    ref.current = fn;\n  });\n\n  return useCallback((...args: Parameters<T>) => {\n    ref.current(...args);\n  }, []);\n}\n","import { createContext, useContext } from 'react';\nimport type { SelectRowEvent } from '../types';\n\nconst RowSelectionContext = createContext<boolean | undefined>(undefined);\n\nexport const RowSelectionProvider = RowSelectionContext.Provider;\n\nconst RowSelectionChangeContext =\n  createContext<((selectRowEvent: SelectRowEvent) => void) | undefined>(undefined);\n\nexport const RowSelectionChangeProvider = RowSelectionChangeContext.Provider;\n\nexport function useRowSelection(): [boolean, (selectRowEvent: SelectRowEvent) => void] {\n  const rowSelectionContext = useContext(RowSelectionContext);\n  const rowSelectionChangeContext = useContext(RowSelectionChangeContext);\n\n  if (rowSelectionContext === undefined || rowSelectionChangeContext === undefined) {\n    throw new Error('useRowSelection must be used within DataGrid cells');\n  }\n\n  return [rowSelectionContext, rowSelectionChangeContext];\n}\n","import { useMemo } from 'react';\n\nimport { getColSpan } from '../utils';\nimport type { CalculatedColumn, GroupRow } from '../types';\n\ninterface ViewportColumnsArgs<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n  colSpanColumns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  summaryRows: readonly SR[] | undefined | null;\n  colOverscanStartIdx: number;\n  colOverscanEndIdx: number;\n  lastFrozenColumnIndex: number;\n  rowOverscanStartIdx: number;\n  rowOverscanEndIdx: number;\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function useViewportColumns<R, SR>({\n  columns,\n  colSpanColumns,\n  rows,\n  summaryRows,\n  colOverscanStartIdx,\n  colOverscanEndIdx,\n  lastFrozenColumnIndex,\n  rowOverscanStartIdx,\n  rowOverscanEndIdx,\n  isGroupRow\n}: ViewportColumnsArgs<R, SR>) {\n  // find the column that spans over a column within the visible columns range and adjust colOverscanStartIdx\n  const startIdx = useMemo(() => {\n    if (colOverscanStartIdx === 0) return 0;\n\n    let startIdx = colOverscanStartIdx;\n\n    const updateStartIdx = (colIdx: number, colSpan: number | undefined) => {\n      if (colSpan !== undefined && colIdx + colSpan > colOverscanStartIdx) {\n        startIdx = colIdx;\n        return true;\n      }\n      return false;\n    };\n\n    for (const column of colSpanColumns) {\n      // check header row\n      const colIdx = column.idx;\n      if (colIdx >= startIdx) break;\n      if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, { type: 'HEADER' }))) {\n        break;\n      }\n\n      // check viewport rows\n      for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n        const row = rows[rowIdx];\n        if (isGroupRow(row)) continue;\n        if (\n          updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, { type: 'ROW', row }))\n        ) {\n          break;\n        }\n      }\n\n      // check summary rows\n      if (summaryRows != null) {\n        for (const row of summaryRows) {\n          if (\n            updateStartIdx(\n              colIdx,\n              getColSpan(column, lastFrozenColumnIndex, { type: 'SUMMARY', row })\n            )\n          ) {\n            break;\n          }\n        }\n      }\n    }\n\n    return startIdx;\n  }, [\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    summaryRows,\n    colOverscanStartIdx,\n    lastFrozenColumnIndex,\n    colSpanColumns,\n    isGroupRow\n  ]);\n\n  return useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    const viewportColumns: CalculatedColumn<R, SR>[] = [];\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n\n      if (colIdx < startIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [startIdx, colOverscanEndIdx, columns]);\n}\n","import { useMemo } from 'react';\nimport { ceil, floor, max, min } from '../utils';\nimport type { GroupRow, GroupByDictionary, RowHeightArgs } from '../types';\n\nconst RENDER_BATCH_SIZE = 8;\n\ninterface ViewportRowsArgs<R> {\n  rawRows: readonly R[];\n  rowHeight: number | ((args: RowHeightArgs<R>) => number);\n  clientHeight: number;\n  scrollTop: number;\n  groupBy: readonly string[];\n  rowGrouper:\n    | ((rows: readonly R[], columnKey: string) => Record<string, readonly R[]>)\n    | undefined\n    | null;\n  expandedGroupIds: ReadonlySet<unknown> | undefined | null;\n  enableVirtualization: boolean;\n}\n\n// https://github.com/microsoft/TypeScript/issues/41808\nfunction isReadonlyArray(arr: unknown): arr is readonly unknown[] {\n  return Array.isArray(arr);\n}\n\nexport function useViewportRows<R>({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds,\n  enableVirtualization\n}: ViewportRowsArgs<R>) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || rowGrouper == null) return [undefined, rawRows.length];\n\n    const groupRows = (\n      rows: readonly R[],\n      [groupByKey, ...remainingGroupByKeys]: readonly string[],\n      startRowIndex: number\n    ): [GroupByDictionary<R>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] =\n          remainingGroupByKeys.length === 0\n            ? [childRows, childRows.length]\n            : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, isGroupRow] = useMemo(() => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, isGroupRow];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n    const expandGroup = (\n      rows: GroupByDictionary<R> | readonly R[],\n      parentId: string | undefined,\n      level: number\n    ): void => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        // TODO: should users have control over the generated key?\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = expandedGroupIds?.has(id) ?? false;\n        const { childRows, childGroups, startRowIndex } = rows[groupKey];\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, isGroupRow];\n\n    function isGroupRow(row: R | GroupRow<R>): row is GroupRow<R> {\n      return allGroupRows.has(row);\n    }\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const { totalRowHeight, getRowTop, getRowHeight, findRowIdx } = useMemo(() => {\n    if (typeof rowHeight === 'number') {\n      return {\n        totalRowHeight: rowHeight * rows.length,\n        getRowTop: (rowIdx: number) => rowIdx * rowHeight,\n        getRowHeight: () => rowHeight,\n        findRowIdx: (offset: number) => floor(offset / rowHeight)\n      };\n    }\n\n    let totalRowHeight = 0;\n    // Calcule the height of all the rows upfront. This can cause performance issues\n    // and we can consider using a similar approach as react-window\n    // https://github.com/bvaughn/react-window/blob/master/src/VariableSizeList.js#L68\n    const rowPositions = rows.map((row: R | GroupRow<R>) => {\n      const currentRowHeight = isGroupRow(row)\n        ? rowHeight({ type: 'GROUP', row })\n        : rowHeight({ type: 'ROW', row });\n      const position = { top: totalRowHeight, height: currentRowHeight };\n      totalRowHeight += currentRowHeight;\n      return position;\n    });\n\n    const validateRowIdx = (rowIdx: number) => {\n      return max(0, min(rows.length - 1, rowIdx));\n    };\n\n    return {\n      totalRowHeight,\n      getRowTop: (rowIdx: number) => rowPositions[validateRowIdx(rowIdx)].top,\n      getRowHeight: (rowIdx: number) => rowPositions[validateRowIdx(rowIdx)].height,\n      findRowIdx(offset: number) {\n        let start = 0;\n        let end = rowPositions.length - 1;\n        while (start <= end) {\n          const middle = start + floor((end - start) / 2);\n          const currentOffset = rowPositions[middle].top;\n\n          if (currentOffset === offset) return middle;\n\n          if (currentOffset < offset) {\n            start = middle + 1;\n          } else if (currentOffset > offset) {\n            end = middle - 1;\n          }\n\n          if (start > end) return end;\n        }\n        return 0;\n      }\n    };\n  }, [isGroupRow, rowHeight, rows]);\n\n  if (!enableVirtualization) {\n    return {\n      rowOverscanStartIdx: 0,\n      rowOverscanEndIdx: rows.length - 1,\n      rows,\n      rowsCount,\n      totalRowHeight,\n      isGroupRow,\n      getRowTop,\n      getRowHeight,\n      findRowIdx\n    };\n  }\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = findRowIdx(scrollTop);\n  const rowVisibleEndIdx = min(rows.length - 1, findRowIdx(scrollTop + clientHeight));\n  const rowOverscanStartIdx = max(\n    0,\n    floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BATCH_SIZE) * RENDER_BATCH_SIZE\n  );\n  const rowOverscanEndIdx = min(\n    rows.length - 1,\n    ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BATCH_SIZE) * RENDER_BATCH_SIZE\n  );\n\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    totalRowHeight,\n    isGroupRow,\n    getRowTop,\n    getRowHeight,\n    findRowIdx\n  };\n}\n","import { css } from '@linaria/core';\nimport type { HeaderRendererProps } from '../types';\nconst headerSortCell = css`\n  cursor: pointer;\n  display: flex;\n`;\n\nconst headerSortCellClassname = `rdg-header-sort-cell ${headerSortCell}`;\n\nconst headerSortName = css`\n  flex-grow: 1;\n  overflow: hidden;\n  overflow: clip;\n  text-overflow: ellipsis;\n`;\n\nconst headerSortNameClassname = `rdg-header-sort-name ${headerSortName}`;\n\ntype SharedHeaderCellProps<R, SR> = Pick<\n  HeaderRendererProps<R, SR>,\n  'sortDirection' | 'onSort' | 'priority'\n>;\ninterface Props<R, SR> extends SharedHeaderCellProps<R, SR> {\n  children: React.ReactNode;\n}\n\nexport default function SortableHeaderCell<R, SR>({\n  onSort,\n  sortDirection,\n  priority,\n  children\n}: Props<R, SR>) {\n  let sortText = '';\n  if (sortDirection === 'ASC') {\n    sortText = '\\u25B2';\n  } else if (sortDirection === 'DESC') {\n    sortText = '\\u25BC';\n  }\n\n  return (\n    <span className={headerSortCellClassname} onClick={(e) => onSort(e.ctrlKey)}>\n      <span className={headerSortNameClassname}>{children}</span>\n      <span>\n        {sortText}\n        {priority}\n      </span>\n    </span>\n  );\n}\n","import { css } from '@linaria/core';\n\nimport type { CalculatedColumn, SortColumn } from './types';\nimport type { HeaderRowProps } from './HeaderRow';\nimport SortableHeaderCell from './headerCells/SortableHeaderCell';\nimport { getCellStyle, getCellClassname } from './utils';\n\nconst cellResizable = css`\n  &::after {\n    content: '';\n    cursor: col-resize;\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    width: 10px;\n  }\n`;\n\nconst cellResizableClassname = `rdg-cell-resizable ${cellResizable}`;\n\ntype SharedHeaderRowProps<R, SR> = Pick<\n  HeaderRowProps<R, SR, React.Key>,\n  'onSortColumnsChange' | 'allRowsSelected' | 'sortColumns'\n>;\n\nexport interface HeaderCellProps<R, SR> extends SharedHeaderRowProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  colSpan: number | undefined;\n  onResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n  onAllRowsSelectionChange: (checked: boolean) => void;\n}\n\nexport default function HeaderCell<R, SR>({\n  column,\n  colSpan,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumns,\n  onSortColumnsChange\n}: HeaderCellProps<R, SR>) {\n  function onPointerDown(event: React.PointerEvent<HTMLDivElement>) {\n    if (event.pointerType === 'mouse' && event.buttons !== 1) {\n      return;\n    }\n\n    const { currentTarget, pointerId } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) {\n      // +1px to account for the border size\n      return;\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (event.pointerId !== pointerId) return;\n      if (event.pointerType === 'mouse' && event.buttons !== 1) {\n        onPointerUp(event);\n        return;\n      }\n      const width = event.clientX + offset - currentTarget.getBoundingClientRect().left;\n      if (width > 0) {\n        onResize(column, width);\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      if (event.pointerId !== pointerId) return;\n      window.removeEventListener('pointermove', onPointerMove);\n      window.removeEventListener('pointerup', onPointerUp);\n    }\n\n    event.preventDefault();\n    window.addEventListener('pointermove', onPointerMove);\n    window.addEventListener('pointerup', onPointerUp);\n  }\n  const sortIndex = sortColumns?.findIndex((sort) => sort.columnKey === column.key);\n  const sortColumn =\n    sortIndex !== undefined && sortIndex > -1 ? sortColumns![sortIndex] : undefined;\n  const sortDirection = sortColumn?.direction;\n  const priority = sortColumn !== undefined && sortColumns!.length > 1 ? sortIndex! + 1 : undefined;\n  const ariaSort =\n    sortDirection && !priority ? (sortDirection === 'ASC' ? 'ascending' : 'descending') : undefined;\n\n  const onSort = (ctrlClick: boolean) => {\n    if (onSortColumnsChange == null) return;\n    const { sortDescendingFirst } = column;\n    if (sortColumn === undefined) {\n      // not currently sorted\n      const nextSort: SortColumn = {\n        columnKey: column.key,\n        direction: sortDescendingFirst ? 'DESC' : 'ASC'\n      };\n      onSortColumnsChange(sortColumns && ctrlClick ? [...sortColumns, nextSort] : [nextSort]);\n    } else {\n      let nextSortColumn: SortColumn | undefined;\n      if (\n        (sortDescendingFirst && sortDirection === 'DESC') ||\n        (!sortDescendingFirst && sortDirection === 'ASC')\n      ) {\n        nextSortColumn = {\n          columnKey: column.key,\n          direction: sortDirection === 'ASC' ? 'DESC' : 'ASC'\n        };\n      }\n      if (ctrlClick) {\n        const nextSortColumns = [...sortColumns!];\n        if (nextSortColumn) {\n          // swap direction\n          nextSortColumns[sortIndex!] = nextSortColumn;\n        } else {\n          // remove sort\n          nextSortColumns.splice(sortIndex!, 1);\n        }\n        onSortColumnsChange(nextSortColumns);\n      } else {\n        onSortColumnsChange(nextSortColumn ? [nextSortColumn] : []);\n      }\n    }\n  };\n\n  function getCell() {\n    if (column.headerRenderer) {\n      return (\n        <column.headerRenderer\n          column={column}\n          sortDirection={sortDirection}\n          priority={priority}\n          onSort={onSort}\n          allRowsSelected={allRowsSelected}\n          onAllRowsSelectionChange={onAllRowsSelectionChange}\n        />\n      );\n    }\n\n    if (column.sortable) {\n      return (\n        <SortableHeaderCell onSort={onSort} sortDirection={sortDirection} priority={priority}>\n          {column.name}\n        </SortableHeaderCell>\n      );\n    }\n\n    return column.name;\n  }\n\n  const className = getCellClassname(column, column.headerCellClass, {\n    [cellResizableClassname]: column.resizable\n  });\n\n  return (\n    <div\n      role=\"columnheader\"\n      aria-colindex={column.idx + 1}\n      aria-sort={ariaSort}\n      aria-colspan={colSpan}\n      className={className}\n      style={getCellStyle(column, colSpan)}\n      onPointerDown={column.resizable ? onPointerDown : undefined}\n    >\n      {getCell()}\n    </div>\n  );\n}\n","import { useCallback, memo } from 'react';\n\nimport HeaderCell from './HeaderCell';\nimport type { CalculatedColumn } from './types';\nimport { assertIsValidKeyGetter, getColSpan } from './utils';\nimport type { DataGridProps } from './DataGrid';\nimport { headerRowClassname } from './style';\n\ntype SharedDataGridProps<R, SR, K extends React.Key> = Pick<\n  DataGridProps<R, SR, K>,\n  'rows' | 'onSelectedRowsChange' | 'rowKeyGetter' | 'sortColumns' | 'onSortColumnsChange'\n>;\n\nexport interface HeaderRowProps<R, SR, K extends React.Key> extends SharedDataGridProps<R, SR, K> {\n  columns: readonly CalculatedColumn<R, SR>[];\n  allRowsSelected: boolean;\n  onColumnResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n  lastFrozenColumnIndex: number;\n}\n\nfunction HeaderRow<R, SR, K extends React.Key>({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumns,\n  onSortColumnsChange,\n  lastFrozenColumnIndex\n}: HeaderRowProps<R, SR, K>) {\n  const handleAllRowsSelectionChange = useCallback(\n    (checked: boolean) => {\n      if (!onSelectedRowsChange) return;\n\n      assertIsValidKeyGetter<R, K>(rowKeyGetter);\n\n      const newSelectedRows = new Set<K>(checked ? rows.map(rowKeyGetter) : undefined);\n      onSelectedRowsChange(newSelectedRows);\n    },\n    [onSelectedRowsChange, rows, rowKeyGetter]\n  );\n\n  const cells = [];\n  for (let index = 0; index < columns.length; index++) {\n    const column = columns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, { type: 'HEADER' });\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    cells.push(\n      <HeaderCell<R, SR>\n        key={column.key}\n        column={column}\n        colSpan={colSpan}\n        onResize={onColumnResize}\n        allRowsSelected={allRowsSelected}\n        onAllRowsSelectionChange={handleAllRowsSelectionChange}\n        onSortColumnsChange={onSortColumnsChange}\n        sortColumns={sortColumns}\n      />\n    );\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={1} // aria-rowindex is 1 based\n      className={headerRowClassname}\n    >\n      {cells}\n    </div>\n  );\n}\n\nexport default memo(HeaderRow) as <R, SR, K extends React.Key>(\n  props: HeaderRowProps<R, SR, K>\n) => JSX.Element;\n","import { forwardRef, memo } from 'react';\nimport type { RefAttributes } from 'react';\nimport { css } from '@linaria/core';\n\nimport { getCellStyle, getCellClassname, isCellEditable } from './utils';\nimport type { CellRendererProps } from './types';\n\nconst cellCopied = css`\n  background-color: #ccccff;\n`;\n\nconst cellCopiedClassname = `rdg-cell-copied ${cellCopied}`;\n\nconst cellDraggedOver = css`\n  background-color: #ccccff;\n\n  &.${cellCopied} {\n    background-color: #9999ff;\n  }\n`;\n\nconst cellDraggedOverClassname = `rdg-cell-dragged-over ${cellDraggedOver}`;\n\nconst cellDragHandle = css`\n  cursor: move;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  width: 8px;\n  height: 8px;\n  background-color: var(--selection-color);\n\n  &:hover {\n    width: 16px;\n    height: 16px;\n    border: 2px solid var(--selection-color);\n    background-color: var(--background-color);\n  }\n`;\n\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\n\nfunction Cell<R, SR>(\n  {\n    className,\n    column,\n    colSpan,\n    isCellSelected,\n    isCopied,\n    isDraggedOver,\n    row,\n    rowIdx,\n    dragHandleProps,\n    onRowClick,\n    onClick,\n    onDoubleClick,\n    onContextMenu,\n    onRowChange,\n    selectCell,\n    ...props\n  }: CellRendererProps<R, SR>,\n  ref: React.Ref<HTMLDivElement>\n) {\n  const { cellClass } = column;\n  className = getCellClassname(\n    column,\n    {\n      [cellCopiedClassname]: isCopied,\n      [cellDraggedOverClassname]: isDraggedOver\n    },\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function selectCellWrapper(openEditor?: boolean | null) {\n    selectCell({ idx: column.idx, rowIdx }, openEditor);\n  }\n\n  function handleClick(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper(column.editorOptions?.editOnClick);\n    onRowClick?.(rowIdx, row, column);\n    onClick?.(event);\n  }\n\n  function handleContextMenu(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper();\n    onContextMenu?.(event);\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper(true);\n    onDoubleClick?.(event);\n  }\n\n  function handleRowChange(newRow: R) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected={isCellSelected}\n      aria-colspan={colSpan}\n      aria-readonly={!isCellEditable(column, row) || undefined}\n      ref={ref}\n      className={className}\n      style={getCellStyle(column, colSpan)}\n      onClick={handleClick}\n      onDoubleClick={handleDoubleClick}\n      onContextMenu={handleContextMenu}\n      {...props}\n    >\n      {!column.rowGroup && (\n        <>\n          <column.formatter\n            column={column}\n            rowIdx={rowIdx}\n            row={row}\n            isCellSelected={isCellSelected}\n            onRowChange={handleRowChange}\n          />\n          {dragHandleProps && <div className={cellDragHandleClassname} {...dragHandleProps} />}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Cell)) as <R, SR>(\n  props: CellRendererProps<R, SR> & RefAttributes<HTMLDivElement>\n) => JSX.Element;\n","import { useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { css } from '@linaria/core';\n\nimport { useLatestFunc } from './hooks';\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CellRendererProps, EditorProps } from './types';\n\n/*\n * To check for outside `mousedown` events, we listen to all `mousedown` events at their birth,\n * i.e. on the window during the capture phase, and at their death, i.e. on the window during the bubble phase.\n *\n * We schedule a check at the birth of the event, cancel the check when the event reaches the \"inside\" container,\n * and trigger the \"outside\" callback when the event bubbles back up to the window.\n *\n * The event can be `stopPropagation()`ed halfway through, so they may not always bubble back up to the window,\n * so an alternative check must be used. The check must happen after the event can reach the \"inside\" container,\n * and not before it run to completion. `requestAnimationFrame` is the best way we know how to achieve this.\n * Usually we want click event handlers from parent components to access the latest commited values,\n * so `mousedown` is used instead of `click`.\n *\n * We must also rely on React's event capturing/bubbling to handle elements rendered in a portal.\n */\n\nconst cellEditing = css`\n  padding: 0;\n`;\n\nconst cellEditingClassname = `rdg-editor-container ${cellEditing}`;\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>, 'colSpan'>;\n\ninterface EditCellProps<R, SR> extends EditorProps<R, SR>, SharedCellRendererProps<R, SR> {\n  onKeyDown: Required<React.HTMLAttributes<HTMLDivElement>>['onKeyDown'];\n}\n\nexport default function EditCell<R, SR>({\n  column,\n  colSpan,\n  row,\n  rowIdx,\n  onRowChange,\n  onClose,\n  onKeyDown,\n  editorPortalTarget\n}: EditCellProps<R, SR>) {\n  const frameRequestRef = useRef<number | undefined>();\n\n  // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `onWindowCaptureMouseDown` might otherwise miss valid mousedown events.\n  // To that end we instead access the latest props via useLatestFunc.\n  const commitOnOutsideMouseDown = useLatestFunc(() => {\n    onRowChange(row, true);\n  });\n\n  function cancelFrameRequest() {\n    cancelAnimationFrame(frameRequestRef.current!);\n  }\n\n  useEffect(() => {\n    function onWindowCaptureMouseDown() {\n      frameRequestRef.current = requestAnimationFrame(commitOnOutsideMouseDown);\n    }\n\n    addEventListener('mousedown', onWindowCaptureMouseDown, { capture: true });\n\n    return () => {\n      removeEventListener('mousedown', onWindowCaptureMouseDown, { capture: true });\n      cancelFrameRequest();\n    };\n  }, [commitOnOutsideMouseDown]);\n\n  const { cellClass } = column;\n  const className = getCellClassname(\n    column,\n    cellEditingClassname,\n    typeof cellClass === 'function' ? cellClass(row) : cellClass\n  );\n\n  let content;\n  if (column.editor != null) {\n    content = (\n      <column.editor\n        column={column}\n        row={row}\n        rowIdx={rowIdx}\n        onRowChange={onRowChange}\n        onClose={onClose}\n        editorPortalTarget={editorPortalTarget}\n      />\n    );\n\n    if (column.editorOptions?.createPortal) {\n      content = createPortal(content, editorPortalTarget);\n    }\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected\n      className={className}\n      style={getCellStyle(column, colSpan)}\n      onKeyDown={onKeyDown}\n      onMouseDownCapture={cancelFrameRequest}\n    >\n      {content}\n    </div>\n  );\n}\n","import { memo, forwardRef } from 'react';\nimport type { RefAttributes, CSSProperties } from 'react';\nimport clsx from 'clsx';\n\nimport { groupRowSelectedClassname, rowClassname } from './style';\nimport { getColSpan } from './utils';\nimport Cell from './Cell';\nimport EditCell from './EditCell';\nimport type { RowRendererProps, SelectedCellProps } from './types';\nimport { RowSelectionProvider } from './hooks';\n\nfunction Row<R, SR>(\n  {\n    cellRenderer,\n    className,\n    rowIdx,\n    isRowSelected,\n    copiedCellIdx,\n    draggedOverCellIdx,\n    lastFrozenColumnIndex,\n    row,\n    viewportColumns,\n    selectedCellProps,\n    onRowClick,\n    rowClass,\n    setDraggedOverRowIdx,\n    onMouseEnter,\n    top,\n    height,\n    onRowChange,\n    selectCell,\n    ...props\n  }: RowRendererProps<R, SR>,\n  ref: React.Ref<HTMLDivElement>\n) {\n  function handleDragEnter(event: React.MouseEvent<HTMLDivElement>) {\n    setDraggedOverRowIdx?.(rowIdx);\n    onMouseEnter?.(event);\n  }\n\n  className = clsx(\n    rowClassname,\n    `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`,\n    {\n      [groupRowSelectedClassname]: selectedCellProps?.idx === -1\n    },\n    rowClass?.(row),\n    className\n  );\n\n  const CellRenderer = cellRenderer ?? Cell;\n  const cells = [];\n\n  for (let index = 0; index < viewportColumns.length; index++) {\n    const column = viewportColumns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, { type: 'ROW', row });\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    const isCellSelected = selectedCellProps?.idx === column.idx;\n    if (selectedCellProps?.mode === 'EDIT' && isCellSelected) {\n      cells.push(\n        <EditCell\n          key={column.key}\n          rowIdx={rowIdx}\n          column={column}\n          colSpan={colSpan}\n          onKeyDown={selectedCellProps.onKeyDown}\n          {...selectedCellProps.editorProps}\n        />\n      );\n      continue;\n    }\n\n    cells.push(\n      <CellRenderer\n        key={column.key}\n        rowIdx={rowIdx}\n        column={column}\n        colSpan={colSpan}\n        row={row}\n        isCopied={copiedCellIdx === column.idx}\n        isDraggedOver={draggedOverCellIdx === column.idx}\n        isCellSelected={isCellSelected}\n        dragHandleProps={\n          isCellSelected ? (selectedCellProps as SelectedCellProps).dragHandleProps : undefined\n        }\n        onFocus={isCellSelected ? (selectedCellProps as SelectedCellProps).onFocus : undefined}\n        onKeyDown={isCellSelected ? selectedCellProps!.onKeyDown : undefined}\n        onRowClick={onRowClick}\n        onRowChange={onRowChange}\n        selectCell={selectCell}\n      />\n    );\n  }\n\n  return (\n    <RowSelectionProvider value={isRowSelected}>\n      <div\n        role=\"row\"\n        ref={ref}\n        className={className}\n        onMouseEnter={handleDragEnter}\n        style={\n          {\n            top,\n            '--row-height': `${height}px`\n          } as unknown as CSSProperties\n        }\n        {...props}\n      >\n        {cells}\n      </div>\n    </RowSelectionProvider>\n  );\n}\n\nexport default memo(forwardRef(Row)) as <R, SR>(\n  props: RowRendererProps<R, SR> & RefAttributes<HTMLDivElement>\n) => JSX.Element;\n","import { memo } from 'react';\n\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CalculatedColumn } from './types';\nimport type { GroupRowRendererProps } from './GroupRow';\n\ntype SharedGroupRowRendererProps<R, SR> = Pick<\n  GroupRowRendererProps<R, SR>,\n  'id' | 'rowIdx' | 'groupKey' | 'childRows' | 'isExpanded' | 'toggleGroup'\n>;\n\ninterface GroupCellProps<R, SR> extends SharedGroupRowRendererProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  isCellSelected: boolean;\n  groupColumnIndex: number;\n}\n\nfunction GroupCell<R, SR>({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  column,\n  groupColumnIndex,\n  toggleGroup: toggleGroupWrapper\n}: GroupCellProps<R, SR>) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  // Only make the cell clickable if the group level matches\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      key={column.key}\n      className={getCellClassname(column)}\n      style={{\n        ...getCellStyle(column),\n        cursor: isLevelMatching ? 'pointer' : 'default'\n      }}\n      onClick={isLevelMatching ? toggleGroup : undefined}\n    >\n      {(!column.rowGroup || groupColumnIndex === column.idx) && column.groupFormatter && (\n        <column.groupFormatter\n          rowIdx={rowIdx}\n          groupKey={groupKey}\n          childRows={childRows}\n          column={column}\n          isExpanded={isExpanded}\n          isCellSelected={isCellSelected}\n          toggleGroup={toggleGroup}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default memo(GroupCell) as <R, SR>(props: GroupCellProps<R, SR>) => JSX.Element;\n","import type { CSSProperties } from 'react';\nimport { memo } from 'react';\nimport clsx from 'clsx';\n\nimport { groupRowClassname, groupRowSelectedClassname, rowClassname } from './style';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport GroupCell from './GroupCell';\nimport type { CalculatedColumn, Position, Omit } from './types';\nimport { RowSelectionProvider } from './hooks';\n\nexport interface GroupRowRendererProps<R, SR>\n  extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  id: string;\n  groupKey: unknown;\n  viewportColumns: readonly CalculatedColumn<R, SR>[];\n  childRows: readonly R[];\n  rowIdx: number;\n  top: number;\n  height: number;\n  level: number;\n  selectedCellIdx: number | undefined;\n  isExpanded: boolean;\n  isRowSelected: boolean;\n  selectCell: (position: Position, enableEditor?: boolean) => void;\n  toggleGroup: (expandedGroupId: unknown) => void;\n}\n\nfunction GroupedRow<R, SR>({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  height,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  toggleGroup,\n  ...props\n}: GroupRowRendererProps<R, SR>) {\n  // Select is always the first column\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({ rowIdx, idx: -1 });\n  }\n\n  return (\n    <RowSelectionProvider value={isRowSelected}>\n      <div\n        role=\"row\"\n        aria-level={level}\n        aria-expanded={isExpanded}\n        className={clsx(\n          rowClassname,\n          groupRowClassname,\n          `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`,\n          {\n            [groupRowSelectedClassname]: selectedCellIdx === -1 // Select row if there is no selected cell\n          }\n        )}\n        onClick={selectGroup}\n        style={\n          {\n            top,\n            '--row-height': `${height}px`\n          } as unknown as CSSProperties\n        }\n        {...props}\n      >\n        {viewportColumns.map((column) => (\n          <GroupCell\n            key={column.key}\n            id={id}\n            rowIdx={rowIdx}\n            groupKey={groupKey}\n            childRows={childRows}\n            isExpanded={isExpanded}\n            isCellSelected={selectedCellIdx === column.idx}\n            column={column}\n            groupColumnIndex={idx}\n            toggleGroup={toggleGroup}\n          />\n        ))}\n      </div>\n    </RowSelectionProvider>\n  );\n}\n\nexport default memo(GroupedRow) as <R, SR>(props: GroupRowRendererProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\n\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CellRendererProps } from './types';\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>, 'column' | 'colSpan'>;\n\ninterface SummaryCellProps<R, SR> extends SharedCellRendererProps<R, SR> {\n  row: SR;\n}\n\nfunction SummaryCell<R, SR>({ column, colSpan, row }: SummaryCellProps<R, SR>) {\n  const { summaryFormatter: SummaryFormatter, summaryCellClass } = column;\n  const className = getCellClassname(\n    column,\n    typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass\n  );\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      aria-colspan={colSpan}\n      className={className}\n      style={getCellStyle(column, colSpan)}\n    >\n      {SummaryFormatter && <SummaryFormatter column={column} row={row} />}\n    </div>\n  );\n}\n\nexport default memo(SummaryCell) as <R, SR>(props: SummaryCellProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport { rowClassname, summaryRowClassname } from './style';\nimport { getColSpan } from './utils';\nimport SummaryCell from './SummaryCell';\nimport type { RowRendererProps } from './types';\n\ntype SharedRowRendererProps<R, SR> = Pick<RowRendererProps<R, SR>, 'viewportColumns' | 'rowIdx'>;\n\ninterface SummaryRowProps<R, SR> extends SharedRowRendererProps<R, SR> {\n  'aria-rowindex': number;\n  row: SR;\n  bottom: number;\n  lastFrozenColumnIndex: number;\n}\n\nfunction SummaryRow<R, SR>({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  lastFrozenColumnIndex,\n  'aria-rowindex': ariaRowIndex\n}: SummaryRowProps<R, SR>) {\n  const cells = [];\n  for (let index = 0; index < viewportColumns.length; index++) {\n    const column = viewportColumns[index];\n    const colSpan = getColSpan(column, lastFrozenColumnIndex, { type: 'SUMMARY', row });\n    if (colSpan !== undefined) {\n      index += colSpan - 1;\n    }\n\n    cells.push(<SummaryCell<R, SR> key={column.key} column={column} colSpan={colSpan} row={row} />);\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      className={`${rowClassname} rdg-row-${\n        rowIdx % 2 === 0 ? 'even' : 'odd'\n      } ${summaryRowClassname}`}\n      style={{ bottom }}\n    >\n      {cells}\n    </div>\n  );\n}\n\nexport default memo(SummaryRow) as <R, SR>(props: SummaryRowProps<R, SR>) => JSX.Element;\n","import {\n  forwardRef,\n  useState,\n  useRef,\n  useLayoutEffect,\n  useImperativeHandle,\n  useCallback,\n  useMemo\n} from 'react';\nimport type { Key, RefAttributes } from 'react';\nimport clsx from 'clsx';\n\nimport { rootClassname, viewportDraggingClassname, focusSinkClassname } from './style';\nimport {\n  useGridDimensions,\n  useCalculatedColumns,\n  useViewportColumns,\n  useViewportRows,\n  useLatestFunc,\n  RowSelectionChangeProvider\n} from './hooks';\nimport HeaderRow from './HeaderRow';\nimport Row from './Row';\nimport GroupRowRenderer from './GroupRow';\nimport SummaryRow from './SummaryRow';\nimport {\n  assertIsValidKeyGetter,\n  onEditorNavigation,\n  getNextSelectedCellPosition,\n  isSelectedCellEditable,\n  canExitGrid,\n  isCtrlKeyHeldDown,\n  isDefaultCellInput,\n  getColSpan,\n  max,\n  sign\n} from './utils';\n\nimport type {\n  CalculatedColumn,\n  Column,\n  Position,\n  RowRendererProps,\n  RowsChangeData,\n  SelectRowEvent,\n  SelectedCellProps,\n  EditCellProps,\n  FillEvent,\n  PasteEvent,\n  CellNavigationMode,\n  SortColumn,\n  RowHeightArgs,\n  SelectCellFn\n} from './types';\n\ninterface SelectCellState extends Position {\n  mode: 'SELECT';\n}\n\ninterface EditCellState<R> extends Position {\n  mode: 'EDIT';\n  row: R;\n  originalRow: R;\n  key: string | null;\n}\n\ntype DefaultColumnOptions<R, SR> = Pick<\n  Column<R, SR>,\n  'formatter' | 'minWidth' | 'resizable' | 'sortable'\n>;\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nconst body = globalThis.document?.body;\n\nconst initialPosition: SelectCellState = {\n  idx: -1,\n  rowIdx: -1,\n  mode: 'SELECT'\n};\n\nexport interface DataGridHandle {\n  element: HTMLDivElement | null;\n  scrollToColumn: (colIdx: number) => void;\n  scrollToRow: (rowIdx: number) => void;\n  selectCell: SelectCellFn;\n}\n\ntype SharedDivProps = Pick<\n  React.HTMLAttributes<HTMLDivElement>,\n  'aria-label' | 'aria-labelledby' | 'aria-describedby' | 'className' | 'style'\n>;\n\nexport interface DataGridProps<R, SR = unknown, K extends Key = Key> extends SharedDivProps {\n  /**\n   * Grid and data Props\n   */\n  /** An array of objects representing each column on the grid */\n  columns: readonly Column<R, SR>[];\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rows: readonly R[];\n  /**\n   * Rows to be pinned at the bottom of the rows view for summary, the vertical scroll bar will not scroll these rows.\n   * Bottom horizontal scroll bar can move the row left / right. Or a customized row renderer can be used to disabled the scrolling support.\n   */\n  summaryRows?: readonly SR[] | null;\n  /** The getter should return a unique key for each row */\n  rowKeyGetter?: ((row: R) => K) | null;\n  onRowsChange?: ((rows: R[], data: RowsChangeData<R, SR>) => void) | null;\n\n  /**\n   * Dimensions props\n   */\n  /** The height of each row in pixels */\n  rowHeight?: number | ((args: RowHeightArgs<R>) => number) | null;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number | null;\n  /** The height of each summary row in pixels */\n  summaryRowHeight?: number | null;\n\n  /**\n   * Feature props\n   */\n  /** Set of selected row keys */\n  selectedRows?: ReadonlySet<K> | null;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?: ((selectedRows: Set<K>) => void) | null;\n  /**Used for multi column sorting */\n  sortColumns?: readonly Readonly<SortColumn>[] | null;\n  onSortColumnsChange?: ((sortColumns: SortColumn[]) => void) | null;\n  defaultColumnOptions?: DefaultColumnOptions<R, SR> | null;\n  groupBy?: readonly string[] | null;\n  rowGrouper?: ((rows: readonly R[], columnKey: string) => Record<string, readonly R[]>) | null;\n  expandedGroupIds?: ReadonlySet<unknown> | null;\n  onExpandedGroupIdsChange?: ((expandedGroupIds: Set<unknown>) => void) | null;\n  onFill?: ((event: FillEvent<R>) => R[]) | null;\n  onPaste?: ((event: PasteEvent<R>) => R) | null;\n\n  /**\n   * Custom renderers\n   */\n  rowRenderer?: React.ComponentType<RowRendererProps<R, SR>> | null;\n  emptyRowsRenderer?: React.ComponentType | null;\n\n  /**\n   * Event props\n   */\n  /** Function called whenever a row is clicked */\n  onRowClick?: ((rowIdx: number, row: R, column: CalculatedColumn<R, SR>) => void) | null;\n  /** Called when the grid is scrolled */\n  onScroll?: ((event: React.UIEvent<HTMLDivElement>) => void) | null;\n  /** Called when a column is resized */\n  onColumnResize?: ((idx: number, width: number) => void) | null;\n  /** Function called whenever selected cell is changed */\n  onSelectedCellChange?: ((position: Position) => void) | null;\n\n  /**\n   * Toggles and modes\n   */\n  cellNavigationMode?: CellNavigationMode | null;\n  enableVirtualization?: boolean | null;\n\n  /**\n   * Miscellaneous\n   */\n  /** The node where the editor portal should mount. */\n  editorPortalTarget?: Element | null;\n  rowClass?: ((row: R) => string | undefined | null) | null;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rows={rows} />\n */\nfunction DataGrid<R, SR, K extends Key>(\n  {\n    // Grid and data Props\n    columns: rawColumns,\n    rows: rawRows,\n    summaryRows,\n    rowKeyGetter,\n    onRowsChange,\n    // Dimensions props\n    rowHeight,\n    headerRowHeight: rawHeaderRowHeight,\n    summaryRowHeight: rawSummaryRowHeight,\n    // Feature props\n    selectedRows,\n    onSelectedRowsChange,\n    sortColumns,\n    onSortColumnsChange,\n    defaultColumnOptions,\n    groupBy: rawGroupBy,\n    rowGrouper,\n    expandedGroupIds,\n    onExpandedGroupIdsChange,\n    // Custom renderers\n    rowRenderer,\n    emptyRowsRenderer: EmptyRowsRenderer,\n    // Event props\n    onRowClick,\n    onScroll,\n    onColumnResize,\n    onSelectedCellChange,\n    onFill,\n    onPaste,\n    // Toggles and modes\n    cellNavigationMode: rawCellNavigationMode,\n    enableVirtualization,\n    // Miscellaneous\n    editorPortalTarget: rawEditorPortalTarget,\n    className,\n    style,\n    rowClass,\n    // ARIA\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-describedby': ariaDescribedBy\n  }: DataGridProps<R, SR, K>,\n  ref: React.Ref<DataGridHandle>\n) {\n  /**\n   * defaults\n   */\n  rowHeight ??= 35;\n  const headerRowHeight = rawHeaderRowHeight ?? (typeof rowHeight === 'number' ? rowHeight : 35);\n  const summaryRowHeight = rawSummaryRowHeight ?? (typeof rowHeight === 'number' ? rowHeight : 35);\n  const RowRenderer = rowRenderer ?? Row;\n  const cellNavigationMode = rawCellNavigationMode ?? 'NONE';\n  enableVirtualization ??= true;\n  const editorPortalTarget = rawEditorPortalTarget ?? body;\n\n  /**\n   * states\n   */\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState<ReadonlyMap<string, number>>(() => new Map());\n  const [selectedPosition, setSelectedPosition] =\n    useState<SelectCellState | EditCellState<R>>(initialPosition);\n  const [copiedCell, setCopiedCell] = useState<{ row: R; columnKey: string } | null>(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState<number | undefined>(undefined);\n\n  /**\n   * refs\n   */\n  const focusSinkRef = useRef<HTMLDivElement>(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n\n  /**\n   * The identity of the wrapper function is stable so it won't break memoization\n   */\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(updateRow);\n\n  /**\n   * computed values\n   */\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = 1;\n  const summaryRowsCount = summaryRows?.length ?? 0;\n  const clientHeight = gridHeight - headerRowHeight - summaryRowsCount * summaryRowHeight;\n  const isSelectable = selectedRows != null && onSelectedRowsChange != null;\n\n  const allRowsSelected = useMemo((): boolean => {\n    // no rows to select = explicitely unchecked\n    const { length } = rawRows;\n    return (\n      length !== 0 &&\n      selectedRows != null &&\n      rowKeyGetter != null &&\n      selectedRows.size >= length &&\n      rawRows.every((row) => selectedRows.has(rowKeyGetter(row)))\n    );\n  }, [rawRows, selectedRows, rowKeyGetter]);\n\n  const {\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useCalculatedColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined,\n    enableVirtualization\n  });\n\n  const {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    totalRowHeight,\n    isGroupRow,\n    getRowTop,\n    getRowHeight,\n    findRowIdx\n  } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds,\n    enableVirtualization\n  });\n\n  const viewportColumns = useViewportColumns({\n    columns,\n    colSpanColumns,\n    colOverscanStartIdx,\n    colOverscanEndIdx,\n    lastFrozenColumnIndex,\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    summaryRows,\n    isGroupRow\n  });\n\n  const hasGroups = groupBy.length > 0 && typeof rowGrouper === 'function';\n  const minColIdx = hasGroups ? -1 : 0;\n\n  // Cell drag is not supported on a treegrid\n  const enableCellDragAndDrop = hasGroups ? false : onFill != null;\n\n  /**\n   * effects\n   */\n  useLayoutEffect(() => {\n    if (\n      selectedPosition === prevSelectedPosition.current ||\n      selectedPosition.mode === 'EDIT' ||\n      !isCellWithinBounds(selectedPosition)\n    ) {\n      return;\n    }\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n    focusSinkRef.current!.focus({ preventScroll: true });\n  });\n\n  useImperativeHandle(ref, () => ({\n    element: gridRef.current,\n    scrollToColumn(idx: number) {\n      scrollToCell({ idx });\n    },\n    scrollToRow(rowIdx: number) {\n      const { current } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: getRowTop(rowIdx),\n        behavior: 'smooth'\n      });\n    },\n    selectCell\n  }));\n\n  /**\n   * callbacks\n   */\n  const handleColumnResize = useCallback(\n    (column: CalculatedColumn<R, SR>, width: number) => {\n      setColumnWidths((columnWidths) => {\n        const newColumnWidths = new Map(columnWidths);\n        newColumnWidths.set(column.key, width);\n        return newColumnWidths;\n      });\n\n      onColumnResize?.(column.idx, width);\n    },\n    [onColumnResize]\n  );\n\n  const setDraggedOverRowIdx = useCallback((rowIdx?: number) => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  /**\n   * event handlers\n   */\n  function selectRow({ rowIdx, checked, isShiftClick }: SelectRowEvent) {\n    if (!onSelectedRowsChange) return;\n\n    assertIsValidKeyGetter<R, K>(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = sign(rowIdx - previousRowIdx);\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId: unknown) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function onGridFocus() {\n    if (!isCellWithinBounds(selectedPosition)) {\n      // Tabbing into the grid should initiate keyboard navigation\n      const initialPosition: SelectCellState = { idx: 0, rowIdx: 0, mode: 'SELECT' };\n      if (isCellWithinBounds(initialPosition)) {\n        setSelectedPosition(initialPosition);\n      }\n    } else {\n      // otherwise if we already have a selected cell, we should scroll back to it when focusing the grid\n      scrollToCell(selectedPosition);\n    }\n  }\n\n  function handleKeyDown(event: React.KeyboardEvent<HTMLDivElement>) {\n    const { key, keyCode } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (\n      onPaste &&\n      isCtrlKeyHeldDown(event) &&\n      isCellWithinBounds(selectedPosition) &&\n      !isGroupRow(row) &&\n      selectedPosition.idx !== -1 &&\n      selectedPosition.mode === 'SELECT'\n    ) {\n      // event.key may differ by keyboard input language, so we use event.keyCode instead\n      // event.nativeEvent.code cannot be used either as it would break copy/paste for the DVORAK layout\n      const cKey = 67;\n      const vKey = 86;\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (\n      isCellWithinBounds(selectedPosition) &&\n      isGroupRow(row) &&\n      selectedPosition.idx === -1 &&\n      // Collapse the current group row if it is focused and is in expanded state\n      ((key === 'ArrowLeft' && row.isExpanded) ||\n        // Expand the current group row if it is focused and is in collapsed state\n        (key === 'ArrowRight' && !row.isExpanded))\n    ) {\n      event.preventDefault(); // Prevents scrolling\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event: React.UIEvent<HTMLDivElement>) {\n    const { scrollTop, scrollLeft } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  function getRawRowIdx(rowIdx: number) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx] as R) : rowIdx;\n  }\n\n  function updateRow(rowIdx: number, row: R) {\n    if (typeof onRowsChange !== 'function') return;\n    if (row === rawRows[rowIdx]) return;\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = row;\n    onRowsChange(updatedRows, {\n      indexes: [rowIdx],\n      column: columns[selectedPosition.idx]\n    });\n  }\n\n  function commitEditorChanges() {\n    if (\n      columns[selectedPosition.idx]?.editor == null ||\n      selectedPosition.mode === 'SELECT' ||\n      selectedPosition.row === selectedPosition.originalRow\n    ) {\n      return;\n    }\n\n    const rowIdx = getRawRowIdx(selectedPosition.rowIdx);\n    updateRow(rowIdx, selectedPosition.row);\n  }\n\n  function handleCopy() {\n    const { idx, rowIdx } = selectedPosition;\n    setCopiedCell({ row: rawRows[getRawRowIdx(rowIdx)], columnKey: columns[idx].key });\n  }\n\n  function handlePaste() {\n    const { idx, rowIdx } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n    if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n\n    updateRow(rowIdx, updatedTargetRow);\n  }\n\n  function handleCellInput(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const { key } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        // Custom editors can listen for the event and stop propagation to prevent commit\n        commitEditorChanges();\n        closeEditor();\n      }\n      return;\n    }\n\n    column.editorOptions?.onCellKeyDown?.(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({ idx, rowIdx }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({ columnKey: column.key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    const indexes: number[] = [];\n\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      const targetRowIdx = i - startRowIndex;\n      if (updatedRows[i] !== updatedTargetRows[targetRowIdx]) {\n        updatedRows[i] = updatedTargetRows[targetRowIdx];\n        indexes.push(i);\n      }\n    }\n\n    if (indexes.length > 0) {\n      onRowsChange(updatedRows, { indexes, column });\n    }\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event: React.MouseEvent<HTMLDivElement, MouseEvent>) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event: MouseEvent) {\n      // Trigger onMouseup in edge cases where we release the mouse button but `mouseup` isn't triggered,\n      // for example when releasing the mouse button outside the iframe the grid is rendered in.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({ columnKey: column.key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    const indexes: number[] = [];\n\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      const targetRowIdx = i - rowIdx - 1;\n      if (updatedRows[i] !== updatedTargetRows[targetRowIdx]) {\n        updatedRows[i] = updatedTargetRows[targetRowIdx];\n        indexes.push(i);\n      }\n    }\n\n    if (indexes.length > 0) {\n      onRowsChange(updatedRows, { indexes, column });\n    }\n  }\n\n  function handleEditorRowChange(row: Readonly<R>, commitChanges?: boolean) {\n    if (selectedPosition.mode === 'SELECT') return;\n    if (commitChanges) {\n      updateRow(getRawRowIdx(selectedPosition.rowIdx), row);\n      closeEditor();\n    } else {\n      setSelectedPosition((position) => ({ ...position, row }));\n    }\n  }\n\n  function handleOnClose(commitChanges?: boolean) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n    closeEditor();\n  }\n\n  /**\n   * utils\n   */\n  function isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position: Position): boolean {\n    return (\n      isCellWithinBounds(position) &&\n      isSelectedCellEditable({ columns, rows, selectedPosition: position, isGroupRow })\n    );\n  }\n\n  function selectCell(position: Position, enableEditor?: boolean | null): void {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx] as R;\n      setSelectedPosition({ ...position, mode: 'EDIT', key: null, row, originalRow: row });\n    } else {\n      setSelectedPosition({ ...position, mode: 'SELECT' });\n    }\n    onSelectedCellChange?.({ ...position });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, mode: 'SELECT' }));\n  }\n\n  function scrollToCell({ idx, rowIdx }: Partial<Position>): void {\n    const { current } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      rowIdx ??= selectedPosition.rowIdx;\n      if (!isCellWithinBounds({ rowIdx, idx })) return;\n      const { clientWidth } = current;\n      const column = columns[idx];\n      const { left, width } = columnMetrics.get(column)!;\n      let right = left + width;\n      const row = rows[rowIdx];\n      if (!isGroupRow(row)) {\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, { type: 'ROW', row });\n        if (colSpan !== undefined) {\n          const { left, width } = columnMetrics.get(columns[column.idx + colSpan - 1])!;\n          right = left + width;\n        }\n      }\n\n      const isCellAtLeftBoundary = left < scrollLeft + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = right > clientWidth + scrollLeft;\n      if (isCellAtLeftBoundary) {\n        current.scrollLeft = left - totalFrozenColumnWidth;\n      } else if (isCellAtRightBoundary) {\n        current.scrollLeft = right - clientWidth;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      const rowTop = getRowTop(rowIdx);\n      const rowHeight = getRowHeight(rowIdx);\n      if (rowTop < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowTop;\n      } else if (rowTop + rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = rowTop + rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key: string, ctrlKey: boolean, shiftKey: boolean): Position {\n    const { idx, rowIdx } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n    if (\n      key === 'ArrowLeft' &&\n      isRowSelected &&\n      isGroupRow(row) &&\n      !row.isExpanded &&\n      row.level !== 0\n    ) {\n      let parentRowIdx = -1;\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n      if (parentRowIdx !== -1) {\n        return { idx, rowIdx: parentRowIdx };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return { idx, rowIdx: rowIdx - 1 };\n      case 'ArrowDown':\n        return { idx, rowIdx: rowIdx + 1 };\n      case 'ArrowLeft':\n        return { idx: idx - 1, rowIdx };\n      case 'ArrowRight':\n        return { idx: idx + 1, rowIdx };\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey\n            ? { idx: columns.length - 1, rowIdx: rows.length - 1 }\n            : { idx: 0, rowIdx: 0 };\n        }\n        return { idx: idx + (shiftKey ? -1 : 1), rowIdx };\n      case 'Home':\n        // If row is selected then move focus to the first row\n        if (isRowSelected) return { idx, rowIdx: 0 };\n        return ctrlKey ? { idx: 0, rowIdx: 0 } : { idx: 0, rowIdx };\n      case 'End':\n        // If row is selected then move focus to the last row.\n        if (isRowSelected) return { idx, rowIdx: rows.length - 1 };\n        return ctrlKey\n          ? { idx: columns.length - 1, rowIdx: rows.length - 1 }\n          : { idx: columns.length - 1, rowIdx };\n      case 'PageUp': {\n        const nextRowY = getRowTop(rowIdx) + getRowHeight(rowIdx) - clientHeight;\n        return { idx, rowIdx: nextRowY > 0 ? findRowIdx(nextRowY) : 0 };\n      }\n      case 'PageDown': {\n        const nextRowY = getRowTop(rowIdx) + clientHeight;\n        return { idx, rowIdx: nextRowY < totalRowHeight ? findRowIdx(nextRowY) : rows.length - 1 };\n      }\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (selectedPosition.mode === 'EDIT') {\n      const onNavigation =\n        columns[selectedPosition.idx].editorOptions?.onNavigation ?? onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n    const { key, shiftKey } = event;\n    let mode = cellNavigationMode;\n    if (key === 'Tab') {\n      // If we are in a position to leave the grid, stop editing but stay in that cell\n      if (\n        canExitGrid({\n          shiftKey,\n          cellNavigationMode,\n          columns,\n          rowsCount: rows.length,\n          selectedPosition\n        })\n      ) {\n        commitEditorChanges();\n        // Allow focus to leave the grid so the next control in the tab order can be focused\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE' ? 'CHANGE_ROW' : cellNavigationMode;\n    }\n\n    // Do not allow focus to leave\n    event.preventDefault();\n\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    const nextPosition = getNextSelectedCellPosition({\n      columns,\n      colSpanColumns,\n      rows,\n      lastFrozenColumnIndex,\n      cellNavigationMode: mode,\n      currentPosition: selectedPosition,\n      nextPosition: getNextPosition(key, ctrlKey, shiftKey),\n      isCellWithinBounds,\n      isGroupRow\n    });\n\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx: number): number | undefined {\n    if (draggedOverRowIdx === undefined) return;\n    const { rowIdx } = selectedPosition;\n\n    const isDraggedOver =\n      rowIdx < draggedOverRowIdx\n        ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx\n        : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx: number): SelectedCellProps | EditCellProps<R> | undefined {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps:\n        enableCellDragAndDrop && isCellEditable(selectedPosition)\n          ? { onMouseDown: handleMouseDown, onDoubleClick: handleDoubleClick }\n          : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = getRowTop(rowIdx) + headerRowHeight;\n      if (isGroupRow(row)) {\n        ({ startRowIndex } = row);\n        const isGroupRowSelected =\n          isSelectable && row.childRows.every((cr) => selectedRows?.has(rowKeyGetter!(cr)));\n        rowElements.push(\n          <GroupRowRenderer\n            aria-level={row.level + 1} // aria-level is 1-based\n            aria-setsize={row.setSize}\n            aria-posinset={row.posInSet + 1} // aria-posinset is 1-based\n            aria-rowindex={headerRowsCount + startRowIndex + 1} // aria-rowindex is 1 based\n            aria-selected={isSelectable ? isGroupRowSelected : undefined}\n            key={row.id}\n            id={row.id}\n            groupKey={row.groupKey}\n            viewportColumns={viewportColumns}\n            childRows={row.childRows}\n            rowIdx={rowIdx}\n            top={top}\n            height={getRowHeight(rowIdx)}\n            level={row.level}\n            isExpanded={row.isExpanded}\n            selectedCellIdx={selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined}\n            isRowSelected={isGroupRowSelected}\n            onFocus={selectedPosition.rowIdx === rowIdx ? handleFocus : undefined}\n            onKeyDown={selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined}\n            selectCell={selectCellWrapper}\n            toggleGroup={toggleGroupWrapper}\n          />\n        );\n        continue;\n      }\n\n      startRowIndex++;\n      let key;\n      let isRowSelected = false;\n      if (typeof rowKeyGetter === 'function') {\n        key = rowKeyGetter(row);\n        isRowSelected = selectedRows?.has(key) ?? false;\n      } else {\n        key = hasGroups ? startRowIndex : rowIdx;\n      }\n\n      rowElements.push(\n        <RowRenderer\n          aria-rowindex={headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1} // aria-rowindex is 1 based\n          aria-selected={isSelectable ? isRowSelected : undefined}\n          key={key}\n          rowIdx={rowIdx}\n          row={row}\n          viewportColumns={viewportColumns}\n          isRowSelected={isRowSelected}\n          onRowClick={onRowClick}\n          rowClass={rowClass}\n          top={top}\n          height={getRowHeight(rowIdx)}\n          copiedCellIdx={\n            copiedCell !== null && copiedCell.row === row\n              ? columns.findIndex((c) => c.key === copiedCell.columnKey)\n              : undefined\n          }\n          draggedOverCellIdx={getDraggedOverCellIdx(rowIdx)}\n          setDraggedOverRowIdx={isDragging ? setDraggedOverRowIdx : undefined}\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          selectedCellProps={getSelectedCellProps(rowIdx)}\n          onRowChange={handleFormatterRowChangeWrapper}\n          selectCell={selectCellWrapper}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition(initialPosition);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (\n    selectedPosition.mode === 'EDIT' &&\n    rows[selectedPosition.rowIdx] !== selectedPosition.originalRow\n  ) {\n    // Discard changes if rows are updated from outside\n    closeEditor();\n  }\n\n  return (\n    <div\n      role={hasGroups ? 'treegrid' : 'grid'}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-describedby={ariaDescribedBy}\n      aria-multiselectable={isSelectable ? true : undefined}\n      aria-colcount={columns.length}\n      aria-rowcount={headerRowsCount + rowsCount + summaryRowsCount}\n      className={clsx(rootClassname, { [viewportDraggingClassname]: isDragging }, className)}\n      style={\n        {\n          ...style,\n          '--header-row-height': `${headerRowHeight}px`,\n          '--row-width': `${totalColumnWidth}px`,\n          '--summary-row-height': `${summaryRowHeight}px`,\n          ...layoutCssVars\n        } as unknown as React.CSSProperties\n      }\n      ref={gridRef}\n      onScroll={handleScroll}\n    >\n      <HeaderRow\n        rowKeyGetter={rowKeyGetter}\n        rows={rawRows}\n        columns={viewportColumns}\n        onColumnResize={handleColumnResize}\n        allRowsSelected={allRowsSelected}\n        onSelectedRowsChange={onSelectedRowsChange}\n        sortColumns={sortColumns}\n        onSortColumnsChange={onSortColumnsChange}\n        lastFrozenColumnIndex={lastFrozenColumnIndex}\n      />\n      {rows.length === 0 && EmptyRowsRenderer ? (\n        <EmptyRowsRenderer />\n      ) : (\n        <>\n          {/*\n            Ideally the focus should be set on the selected cell\n            (https://www.w3.org/TR/wai-aria-practices-1.2/#kbd_roving_tabindex)\n            but there are a few issues with this approach\n            - onKeyDown/useLayoutEffect on the cell is not fast enough and grid\n              looses focus if tab is pressed repeatedly\n            - All the cells are not rendered so it is possible the focused cell\n              is not in the viewport and unmounted and in this case the grid\n              does not have any focusable element\n\n            This first issue can be solved by setting onKeyDown on the root element\n            but for the second issue we need to render the selected cell along with\n            the cells in the viewport. This adds complexity.\n\n            To circumvent this issue we are using an extra div element which is\n            positioned on the top/left corner of the viewport and it listens for the\n            keyboard event and sets the selected cell's position.\n          */}\n          <div\n            ref={focusSinkRef}\n            tabIndex={0}\n            className={focusSinkClassname}\n            onKeyDown={handleKeyDown}\n            onFocus={onGridFocus}\n          />\n          <div style={{ height: max(totalRowHeight, clientHeight) }} />\n          <RowSelectionChangeProvider value={selectRowWrapper}>\n            {getViewportRows()}\n          </RowSelectionChangeProvider>\n          {summaryRows?.map((row, rowIdx) => (\n            <SummaryRow\n              aria-rowindex={headerRowsCount + rowsCount + rowIdx + 1}\n              key={rowIdx}\n              rowIdx={rowIdx}\n              row={row}\n              bottom={summaryRowHeight * (summaryRows.length - 1 - rowIdx)}\n              viewportColumns={viewportColumns}\n              lastFrozenColumnIndex={lastFrozenColumnIndex}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(DataGrid) as <R, SR = unknown, K extends Key = Key>(\n  props: DataGridProps<R, SR, K> & RefAttributes<DataGridHandle>\n) => JSX.Element;\n","import { css } from '@linaria/core';\nimport type { EditorProps } from '../types';\n\nconst textEditor = css`\n  appearance: none;\n\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  padding: 0px 6px 0 6px;\n  border: 2px solid #ccc;\n  vertical-align: top;\n  color: var(--color);\n  background-color: var(--background-color);\n\n  font-family: inherit;\n  font-size: var(--font-size);\n\n  &:focus {\n    border-color: var(--selection-color);\n    outline: none;\n  }\n\n  &::placeholder {\n    color: #999;\n    opacity: 1;\n  }\n`;\n\nexport const textEditorClassname = `rdg-text-editor ${textEditor}`;\n\nfunction autoFocusAndSelect(input: HTMLInputElement | null) {\n  input?.focus();\n  input?.select();\n}\n\nexport default function TextEditor<TRow, TSummaryRow>({\n  row,\n  column,\n  onRowChange,\n  onClose\n}: EditorProps<TRow, TSummaryRow>) {\n  return (\n    <input\n      className={textEditorClassname}\n      ref={autoFocusAndSelect}\n      value={row[column.key as keyof TRow] as unknown as string}\n      onChange={(event) => onRowChange({ ...row, [column.key]: event.target.value })}\n      onBlur={() => onClose(true)}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}